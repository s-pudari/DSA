
class Solution {

    /**
     * Problem: Count ways to reach the nth stair if you can take 1 or 2 steps at a time
     */

    // -----------------------------------------------------------------------------------
    // Optimized Approach 1: Top-down Dynamic Programming (Memoization)
    // -----------------------------------------------------------------------------------
    /*
     * Time Complexity: O(n)
     * Space Complexity: O(n) for memoization array + recursion stack
     *
     * Dry Run (n = 4):
     * ----------------
     * rec(4) = rec(3) + rec(2)
     *       = (rec(2) + rec(1)) + (rec(1) + rec(0))
     *       = ((rec(1) + rec(0)) + 1) + (1 + 1)
     *       = ((1 + 1) + 1) + 2 = 5
     */

    int rec(int n, int[] dp) {
        if (n == 0 || n == 1) {
            return dp[n] = 1;  // Base case: 1 way to stay or 1 step
        }

        if (dp[n] != -1) {
            return dp[n]; // Already computed
        }

        return dp[n] = rec(n - 1, dp) + rec(n - 2, dp); // Compute and store
    }

    int countWays(int n) {
        int[] dp = new int[n + 1];

        for (int i = 0; i <= n; i++) {
            dp[i] = -1;
        }

        return rec(n, dp);
    }

    // -----------------------------------------------------------------------------------
    // Optimized Approach 2: Bottom-up Dynamic Programming (Tabulation)
    // -----------------------------------------------------------------------------------
    /*
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * Dry Run (n = 4):
     * ----------------
     * dp[0] = 1 (1 way to stay)
     * dp[1] = 1 (1 way to take 1 step)
     * dp[2] = dp[1] + dp[0] = 1 + 1 = 2
     * dp[3] = dp[2] + dp[1] = 2 + 1 = 3
     * dp[4] = dp[3] + dp[2] = 3 + 2 = 5
     */

    int countWaysTab(int n) {
        if (n == 0 || n == 1) return 1;

        int[] dp = new int[n + 1];
        dp[0] = 1;  // 1 way to stay on the ground
        dp[1] = 1;  // 1 way to reach step 1

        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2]; // Sum of the ways to reach previous two steps
        }

        return dp[n];
    }

    // -----------------------------------------------------------------------------------
    // Optimized Approach 3: Space Optimized Approach
    // -----------------------------------------------------------------------------------
    /*
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * Dry Run (n = 4):
     * ----------------
     * prev2 = 1 (ways to reach step 0)
     * prev1 = 1 (ways to reach step 1)
     * i=2: curr = 1+1 = 2 → prev2=1, prev1=2
     * i=3: curr = 2+1 = 3 → prev2=2, prev1=3
     * i=4: curr = 3+2 = 5 → prev2=3, prev1=5
     * Final answer = 5
     */

    int countWaysSpaceOpt(int n) {
        if (n == 0 || n == 1) return 1;

        int prev2 = 1;  // Ways to reach step 0
        int prev1 = 1;  // Ways to reach step 1

        for (int i = 2; i <= n; i++) {
            int curr = prev1 + prev2;  // Current step depends on previous two
            prev2 = prev1;             // Slide window
            prev1 = curr;
        }

        return prev1; // Final answer
    }

    // -----------------------------------------------------------------------------------
    /*
     * Brute-force Recursive Approach (Without Memoization)
     *
     * Time Complexity: O(2^n)
     * Space Complexity: O(n) recursion stack
     *
     * Dry Run (n = 4):
     * ----------------
     * countWays(4) = countWays(3) + countWays(2)
     *             = (countWays(2) + countWays(1)) + (countWays(1) + countWays(0))
     *             = ((1 + 1) + 1) + (1 + 1)
     *             = 5
     */
    /*
    int countWaysBrute(int n) {
        if (n == 0 || n == 1) {
            return 1;
        }

        return countWaysBrute(n - 1) + countWaysBrute(n - 2);
    }
    */
}
