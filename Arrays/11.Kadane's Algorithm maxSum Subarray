https://leetcode.com/problems/maximum-subarray/

/**
 * âœ… PROBLEM: Maximum Subarray Sum (Kadaneâ€™s Problem)
 * -----------------------------------------------------
 * Given an integer array `arr[]`, find the **maximum sum of any contiguous subarray**.
 * 
 * ğŸ§  EXAMPLE:
 * Input:  arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
 * Output: 6
 * âœ… Explanation: The subarray [4, -1, 2, 1] has the maximum sum = 6
 * 
 * ----------------------------------------
 * âœ… APPROACH 1: Kadaneâ€™s Algorithm (Optimized)
 * ----------------------------------------
 * â–¶ï¸ Traverse the array while maintaining:
 *   - `maxEnd` â†’ Maximum subarray sum ending at current index
 *   - `res`    â†’ Global maximum subarray sum
 *
 * âœ… Time Complexity: O(n)
 * âœ… Space Complexity: O(1)
 *
 * ğŸ” DRY RUN:
 * Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]
 * Step-by-step maxEnd: -2 â†’ 1 â†’ -2 â†’ 4 â†’ 3 â†’ 5 â†’ 6 â†’ 1 â†’ 5
 * Final result: 6
 */

class Solution {
    int maxSubarraySum(int[] arr) {
        // Initialize result with first element (in case all elements are negative)
        int res = arr[0];
        
        // maxEnd keeps track of maximum sum ending at current index
        int maxEnd = arr[0];
        
        for (int i = 1; i < arr.length; i++) {
            /*
             * ğŸ” Either we:
             * - Extend the previous subarray (maxEnd + arr[i])
             * - Or start a new subarray from current element (arr[i])
             */
            maxEnd = Math.max(maxEnd + arr[i], arr[i]);
            
            // ğŸ” Update result with max so far
            res = Math.max(res, maxEnd);
        }

        return res;
    }

    /*
     * --------------------------------------------
     * âœ… APPROACH 2: Two Pointer (ONLY for +ve arrays)
     * --------------------------------------------
     * ğŸ§  IDEA:
     * - Maintain a sliding window [start...end] such that:
     *   - If sum becomes negative, reset window
     * 
     * âš ï¸ NOTE: This only works correctly when array has **only positive elements and zeros**.
     * âœ… TIME: O(n)
     * âœ… SPACE: O(1)
     */

    /*
    int maxSubarraySum(int[] arr) {
        int left = 0;
        int sum = 0;
        int maxSum = Integer.MIN_VALUE;

        for (int right = 0; right < arr.length; right++) {
            sum += arr[right];

            // Update max if current sum is greater
            maxSum = Math.max(maxSum, sum);

            // If sum < 0, reset window from next index
            if (sum < 0) {
                sum = 0;
                left = right + 1;
            }
        }

        return maxSum;
    }
    */

    /*
     * --------------------------------------------
     * âœ… APPROACH 3: BRUTE FORCE (Commented)
     * --------------------------------------------
     * â–¶ï¸ Try all subarrays, calculate sum, track maximum.
     * âœ… TIME COMPLEXITY: O(n^2)
     * âœ… SPACE COMPLEXITY: O(1)
     */

    /*
    int maxSubarraySum(int[] arr) {
        int maxSum = Integer.MIN_VALUE;
        for (int i = 0; i < arr.length; i++) {
            int sum = 0;
            for (int j = i; j < arr.length; j++) {
                sum += arr[j];
                maxSum = Math.max(maxSum, sum);
            }
        }
        return maxSum;
    }
    */
}
