/*
🧠 Problem Name: Inversion of Array

🔍 Problem Explanation:
You're given an array of integers. Your task is to count the number of **inversions** in the array.

An **inversion** is defined as a pair (i, j) such that **i < j** and **arr[i] > arr[j]**.
In simpler terms, you’re counting how many elements are "out of order".

📍 GFG Problem Link: 
https://www.geeksforgeeks.org/batch/gfg-160-problems/track/sorting-gfg-160/problem/inversion-of-array-1587115620
*/

/* ----------------------------------------
🔴 Brute Force Approach
-------------------------------------------
🕒 Time Complexity: O(n²)
🧠 Space Complexity: O(1)

👨‍🏫 Explanation:
We use two nested loops to check each possible pair (i, j) such that i < j. 
If arr[i] > arr[j], it's an inversion. Count it.

🧪 Dry Run:
Let’s say: arr = [2, 4, 1, 3, 5]

- Pairs to consider: (2,4), (2,1), (2,3), (2,5), (4,1), (4,3), (4,5), ...
- Inversions: (2,1), (4,1), (4,3)
→ Total inversions = 3
*/

class Solution {
    static int inversionCount(int arr[]) {
        int n = arr.length;
        int cnt = 0;

        // Loop over each pair (i, j) where i < j
        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                if (arr[i] > arr[j]) {
                    cnt++; // Found an inversion
                }
            }
        }
        return cnt;
    }
}
/* ----------------------------------------
✅ Optimized Approach: Using Merge Sort
-------------------------------------------
🕒 Time Complexity: O(n log n)
🧠 Space Complexity: O(n)

👨‍🏫 Explanation:
We enhance merge sort to count inversions during the merge step.

When merging two sorted subarrays:
If an element from the right half is less than an element from the left half,
it means **all remaining elements in the left half** will form inversions with this element.

🧪 Dry Run Example:
Let’s take: arr = [2, 4, 1, 3, 5]

- mergeSort([2, 4, 1, 3, 5]) divides and merges like this:
  → Left: [2, 4], Right: [1, 3, 5]
  → When merging [2, 4] and [1], since 1 < 2 and 1 < 4 → 2 inversions
  → Merging [3, 5] with previous → 1 more inversion (4 > 3)
  → Total = 3
*/

class Solution {
    static int inversionCount(int arr[]) {
        int n = arr.length;
        return mergeSort(arr, 0, n - 1);
    }

    // Recursive merge sort function
    static int mergeSort(int[] arr, int low, int high) {
        int count = 0;
        if (low >= high) return count;

        int mid = low + (high - low) / 2;

        // Sort left half and count inversions
        count += mergeSort(arr, low, mid);

        // Sort right half and count inversions
        count += mergeSort(arr, mid + 1, high);

        // Merge two halves and count cross-inversions
        count += merge(arr, low, mid, high);

        return count;
    }

    // Merge function with inversion count
    static int merge(int[] arr, int low, int mid, int high) {
        int cnt = 0;
        int left = low, right = mid + 1;

        ArrayList<Integer> temp = new ArrayList<>();

        /* Merge both halves into a sorted array */
        while (left <= mid && right <= high) {
            if (arr[left] <= arr[right]) {
                temp.add(arr[left]);
                left++;
            } else {
                temp.add(arr[right]);
                cnt += (mid - left + 1); // All remaining in left half are inversions
                right++;
            }
        }

        // Copy remaining elements from left half
        while (left <= mid) {
            temp.add(arr[left]);
            left++;
        }

        // Copy remaining elements from right half
        while (right <= high) {
            temp.add(arr[right]);
            right++;
        }

        // Copy merged elements back to original array
        for (int i = low; i <= high; i++) {
            arr[i] = temp.get(i - low);
        }

        return cnt;
    }
}

