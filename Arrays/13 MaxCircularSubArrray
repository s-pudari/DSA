/**
 * 🔍 PROBLEM: Maximum Circular Subarray Sum
 * ------------------------------------------
 * Given a **circular** integer array `arr[]`, find the maximum sum of a 
 * contiguous subarray. The array wraps around, so subarrays can span from 
 * the end to the beginning.
 *
 * ✅ Example:
 * Input:  arr = [8, -1, 3, 4]
 * Output: 15
 * Explanation: Max sum circular subarray = [3, 4, 8]
 *
 * ----------------------------------------------------------------
 * ✅ APPROACH 1: Brute Force (Try All Circular Subarrays)
 * ----------------------------------------------------------------
 * 🔍 IDEA:
 * - Try every possible circular subarray using modular indexing.
 * - For each starting point, add the next n elements circularly.
 *
 * 📌 DRY RUN:
 * For arr = [8, -1, 3, 4]
 * i = 0: 8 → 8 + (-1) → 7 → 7 + 3 → 10 → 10 + 4 → 14
 * i = 1: -1 → +3 → +4 → +8 → total = 14
 * i = 2: 3 + 4 + 8 + (-1) = 14
 * i = 3: 4 + 8 + (-1) + 3 = 14
 * max = 14
 *
 * ✅ TIME COMPLEXITY: O(n²)
 * ✅ SPACE COMPLEXITY: O(1)
 */

class Solution {
    
    public int circularSubarraySum(int arr[]) {
        int n = arr.length;
        int res = arr[0];  // Start with first element as initial max

        for (int i = 0; i < n; i++) {
            int currSum = 0;

            // 🌐 Add next n elements circularly starting from i
            for (int j = 0; j < n; j++) {
                int idx = (i + j) % n;  // Wrap around using modulo
                currSum += arr[idx];
                res = Math.max(res, currSum);
            }
        }

        return res;
    }

    /*
     * ----------------------------------------------------------------
     * ✅ APPROACH 2: Optimized (Kadane's + Wraparound)
     * ----------------------------------------------------------------
     * 🔑 IDEA:
     * There are two cases:
     * 1️⃣ The max subarray is **non-circular** (normal Kadane's Algorithm)
     * 2️⃣ The max subarray is **circular**, like: [suffix] + [prefix]
     *     -> Total sum - minimum subarray sum (to "cut" the min part out)
     *
     * 🌟 Final Result = max(Kadane's, totalSum - minSubarraySum)
     * ❗ Edge Case: If all numbers are negative, return the max single element.
     *
     * 📌 DRY RUN: arr = [8, -1, 3, 4]
     * Kadane max: 8 + (-1) + 3 + 4 = 14
     * Min subarray: -1
     * totalSum = 14
     * totalSum - min = 15 → Circular max
     * Answer = max(14, 15) = 15
     *
     * ✅ TIME COMPLEXITY: O(n)
     * ✅ SPACE COMPLEXITY: O(1)
     */
    
    public int circularSubarraySumOptimized(int arr[]) {
        int n = arr.length;

        int globalMin = 0, globalMax = 0; // 🟢 Track overall max and min subarray sums
        int currMin = 0, currMax = 0;     // 🌀 Current subarray sums while traversing
        int totalSum = 0;                 // ➕ Sum of all elements in the array

        for (int i = 0; i < n; i++) {
            // 🟢 Minimum subarray (for wrapping calculation)
            currMin = Math.min(currMin + arr[i], arr[i]);
            globalMin = Math.min(globalMin, currMin);

            // 🔵 Maximum subarray (Kadane's)
            currMax = Math.max(currMax + arr[i], arr[i]);
            globalMax = Math.max(globalMax, currMax);

            totalSum += arr[i];  // Add to total sum
        }

        // ❗ Edge case: all elements are negative
        if (globalMax < 0) {
            return globalMax;
        }

        // 🔁 Either take non-wrapped max or circular wrapped max
        return Math.max(globalMax, totalSum - globalMin);
    }
}

