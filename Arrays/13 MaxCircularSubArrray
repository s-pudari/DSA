/**
 * ğŸ” PROBLEM: Maximum Circular Subarray Sum
 * ------------------------------------------
 * Given a **circular** integer array `arr[]`, find the maximum sum of a 
 * contiguous subarray. The array wraps around, so subarrays can span from 
 * the end to the beginning.
 *
 * âœ… Example:
 * Input:  arr = [8, -1, 3, 4]
 * Output: 15
 * Explanation: Max sum circular subarray = [3, 4, 8]
 *
 * ----------------------------------------------------------------
 * âœ… APPROACH 1: Brute Force (Try All Circular Subarrays)
 * ----------------------------------------------------------------
 * ğŸ” IDEA:
 * - Try every possible circular subarray using modular indexing.
 * - For each starting point, add the next n elements circularly.
 *
 * ğŸ“Œ DRY RUN:
 * For arr = [8, -1, 3, 4]
 * i = 0: 8 â†’ 8 + (-1) â†’ 7 â†’ 7 + 3 â†’ 10 â†’ 10 + 4 â†’ 14
 * i = 1: -1 â†’ +3 â†’ +4 â†’ +8 â†’ total = 14
 * i = 2: 3 + 4 + 8 + (-1) = 14
 * i = 3: 4 + 8 + (-1) + 3 = 14
 * max = 14
 *
 * âœ… TIME COMPLEXITY: O(nÂ²)
 * âœ… SPACE COMPLEXITY: O(1)
 */

class Solution {
    
    public int circularSubarraySum(int arr[]) {
        int n = arr.length;
        int res = arr[0];  // Start with first element as initial max

        for (int i = 0; i < n; i++) {
            int currSum = 0;

            // ğŸŒ Add next n elements circularly starting from i
            for (int j = 0; j < n; j++) {
                int idx = (i + j) % n;  // Wrap around using modulo
                currSum += arr[idx];
                res = Math.max(res, currSum);
            }
        }

        return res;
    }

    /*
     * ----------------------------------------------------------------
     * âœ… APPROACH 2: Optimized (Kadane's + Wraparound)
     * ----------------------------------------------------------------
     * ğŸ”‘ IDEA:
     * There are two cases:
     * 1ï¸âƒ£ The max subarray is **non-circular** (normal Kadane's Algorithm)
     * 2ï¸âƒ£ The max subarray is **circular**, like: [suffix] + [prefix]
     *     -> Total sum - minimum subarray sum (to "cut" the min part out)
     *
     * ğŸŒŸ Final Result = max(Kadane's, totalSum - minSubarraySum)
     * â— Edge Case: If all numbers are negative, return the max single element.
     *
     * ğŸ“Œ DRY RUN: arr = [8, -1, 3, 4]
     * Kadane max: 8 + (-1) + 3 + 4 = 14
     * Min subarray: -1
     * totalSum = 14
     * totalSum - min = 15 â†’ Circular max
     * Answer = max(14, 15) = 15
     *
     * âœ… TIME COMPLEXITY: O(n)
     * âœ… SPACE COMPLEXITY: O(1)
     */
    
    public int circularSubarraySumOptimized(int arr[]) {
        int n = arr.length;

        int globalMin = 0, globalMax = 0; // ğŸŸ¢ Track overall max and min subarray sums
        int currMin = 0, currMax = 0;     // ğŸŒ€ Current subarray sums while traversing
        int totalSum = 0;                 // â• Sum of all elements in the array

        for (int i = 0; i < n; i++) {
            // ğŸŸ¢ Minimum subarray (for wrapping calculation)
            currMin = Math.min(currMin + arr[i], arr[i]);
            globalMin = Math.min(globalMin, currMin);

            // ğŸ”µ Maximum subarray (Kadane's)
            currMax = Math.max(currMax + arr[i], arr[i]);
            globalMax = Math.max(globalMax, currMax);

            totalSum += arr[i];  // Add to total sum
        }

        // â— Edge case: all elements are negative
        if (globalMax < 0) {
            return globalMax;
        }

        // ğŸ” Either take non-wrapped max or circular wrapped max
        return Math.max(globalMax, totalSum - globalMin);
    }
}

