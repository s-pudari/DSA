/*
Problem: Rearrange Array Elements by Sign
LeetCode: https://leetcode.com/problems/rearrange-array-elements-by-sign/

Problem Explanation:
We are given an array of integers nums of even length, consisting of equal numbers of positive and negative integers.
We need to rearrange the array such that:
- Every consecutive pair has nums[i] > 0 and nums[i+1] < 0
- The relative order of positives and negatives should be preserved
Return the rearranged array.

Sample Input: nums = [3,1,-2,-5,2,-4]
Sample Output: [3,-2,1,-5,2,-4]
Explanation: Positives = [3,1,2], Negatives = [-2,-5,-4]
Alternate them → [3,-2,1,-5,2,-4]
*/

/*---------------------------------------------------------
Approach 1: Brute Force (Using Separate Arrays)
Time Complexity: O(n)
Space Complexity: O(n)

Explanation:
- Create two separate arrays → one for positives, one for negatives.
- Traverse nums and fill them accordingly.
- Then merge both arrays back into result[] alternately.

Dry Run:
nums = [3,1,-2,-5,2,-4]
Positives → [3,1,2]
Negatives → [-2,-5,-4]
Now merge:
result[0]=3, result[1]=-2
result[2]=1, result[3]=-5
result[4]=2, result[5]=-4
→ [3,-2,1,-5,2,-4]
*/

class SolutionBrute {
    public int[] rearrangeArray(int[] nums) {
        int n = nums.length;
        int[] pos = new int[n / 2];
        int[] neg = new int[n / 2];
        int p = 0, q = 0;

        // Separate positives and negatives
        for (int num : nums) {
            if (num > 0) pos[p++] = num;
            else neg[q++] = num;
        }

        int[] result = new int[n];
        int idx = 0;
        for (int i = 0; i < n / 2; i++) {
            result[idx++] = pos[i];
            result[idx++] = neg[i];
        }
        return result;
    }
}

/*---------------------------------------------------------
Approach 2: Optimized (Direct Placement with Two Pointers)
Time Complexity: O(n)
Space Complexity: O(n)

Explanation:
- Create a new array of the same size.
- Use two pointers: `pos` starts at 0 for positives, `neg` starts at 1 for negatives.
- Traverse nums:
   - If element is positive → place at arr[pos] and pos+=2
   - If element is negative → place at arr[neg] and neg+=2
- This directly arranges positives and negatives alternatively.

Dry Run:
nums = [3,1,-2,-5,2,-4]
n=6, pos=0, neg=1, arr=[0,0,0,0,0,0]

i=0 → nums[0]=3 >0 → arr[0]=3 → pos=2
i=1 → nums[1]=1 >0 → arr[2]=1 → pos=4
i=2 → nums[2]=-2 <0 → arr[1]=-2 → neg=3
i=3 → nums[3]=-5 <0 → arr[3]=-5 → neg=5
i=4 → nums[4]=2 >0 → arr[4]=2 → pos=6
i=5 → nums[5]=-4 <0 → arr[5]=-4 → neg=7

Final arr = [3,-2,1,-5,2,-4]
*/

class SolutionOptimized {
    public int[] rearrangeArray(int[] nums) {
        int n = nums.length;
        int[] arr = new int[n];
        int pos = 0, neg = 1;

        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) {
                arr[pos] = nums[i];
                pos += 2;
            } else {
                arr[neg] = nums[i];
                neg += 2;
            }
        }
        return arr;
    }
}

/*---------------------------------------------------------
Driver Code (for testing)
---------------------------------------------------------
public class Main {
    public static void main(String[] args) {
        SolutionBrute brute = new SolutionBrute();
        SolutionOptimized opt = new SolutionOptimized();

        int[] nums = {3,1,-2,-5,2,-4};

        // Brute force output
        int[] ans1 = brute.rearrangeArray(nums);
        System.out.print("Brute Force: ");
        for(int x: ans1) System.out.print(x + " ");
        System.out.println();

        // Optimized output
        int[] ans2 = opt.rearrangeArray(nums);
        System.out.print("Optimized: ");
        for(int x: ans2) System.out.print(x + " ");
        // Output: 3 -2 1 -5 2 -4
    }
}
*/
