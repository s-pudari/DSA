/*
Problem Name: Pow(x, n)
Link: https://leetcode.com/problems/powx-n/

Problem Statement:
Implement the function myPow(x, n), which calculates x raised to the power n (i.e., xâ¿).

Constraints:
- x is a double.
- n is an integer and can be negative, zero, or positive.
- Don't use built-in library functions like Math.pow().

---

ğŸ§  Approach 1: Recursive (Brute-force with Divide and Conquer)
Time Complexity: O(log n)
Space Complexity: O(log n) due to recursion stack

Explanation:
- If exponent is 0 â†’ return 1 (base case)
- If exponent is negative â†’ recursively call with positive exponent and take reciprocal.
- Divide exponent by 2 at each step, and multiply results:
   - If even: xâ¿ = (xâ¿/Â²)Â²
   - If odd: xâ¿ = x Ã— (xâ¿/Â²)Â²

Dry Run:
base = 2.0, exp = 5  
â†’ call myPow(2.0, 5)  
â†’ exp is odd â†’ return 2 Ã— myPow(2.0, 2)Â²  
â†’ myPow(2.0, 2) = myPow(2.0, 1)Â²  
â†’ and so on...

âš ï¸ This approach causes a stack overflow for large inputs like n = -2Â³Â¹ (Integer.MIN_VALUE)
*/


public double myPow(double base, int exp) {
    if (exp == 0) return 1;       // xâ° = 1
    if (base == 0) return 0;      // 0^anything = 0

    if (exp < 0) return 1 / myPow(base, -exp); // handle negative exponents

    double half = myPow(base, exp / 2);

    if (exp % 2 == 0) {
        return half * half;
    } else {
        return base * half * half;
    }
}



/*
âœ… Approach 2: Iterative Fast Exponentiation (Optimized)
Time Complexity: O(log n)
Space Complexity: O(1)

Explanation:
- Convert exponent to a positive long to avoid overflow for Integer.MIN_VALUE.
- Keep squaring the base and reducing the exponent:
   - If exponent is odd: multiply result by base and decrement exponent.
   - If exponent is even: square the base and halve the exponent.

Dry Run:
base = 2.0, exp = 10  
res = 1  
exp is even â†’ base = 4, exp = 5  
exp is odd â†’ res *= base â†’ res = 4, base = 16, exp = 2  
exp is even â†’ base = 256, exp = 1  
exp is odd â†’ res *= base â†’ res = 1024

Final answer: 1024
*/

class Solution {
    public double myPow(double base, int exp) {
        double res = 1.0;

        // Use long to safely handle INT_MIN
        long pow = Math.abs((long) exp);

        // Fast exponentiation loop
        while (pow > 0) {
            if (pow % 2 == 1) {
                /* If power is odd, multiply result by current base */
                res *= base;
                pow--; // Decrease exponent by 1 to make it even
            } else {
                /* If power is even, square the base and halve the exponent */
                base *= base;
                pow = pow / 2;
            }
        }

        // If exponent was negative, return reciprocal
        return (exp >= 0) ? res : 1 / res;
    }
}
