/*
ðŸ”· Problem: 4Sum

ðŸ”¹ Problem Statement (in simple words):
You are given an array `nums` and a target value `target`. Your job is to find all **unique combinations of 4 numbers** (quadruplets) in the array that add up to the target.

âœ… Example:
Input: nums = [1, 0, -1, 0, -2, 2], target = 0  
Output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]

ðŸ”— Problem Link: https://leetcode.com/problems/4sum/
*/

import java.util.*;

class Solution {

    // ---------------------------------------------------
    // ðŸ”¶ APPROACH 1: BRUTE FORCE (4 Nested Loops)
    // ---------------------------------------------------
    /*
    ðŸ”¸ Time Complexity: O(N^4) â€” Four nested loops  
    ðŸ”¸ Space Complexity: O(K) â€” K = number of unique quadruplets (for HashSet)

    ðŸ”¸ How It Works:
    - We use four nested loops to explore all combinations of 4 elements.
    - If their sum matches the target, we store the sorted quadruplet in a HashSet to avoid duplicates.

    ðŸ”¸ Dry Run:
    Input: nums = [1, 0, -1, 0, -2, 2], target = 0
    -> Check all 4-element combinations:
       [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1], etc.
    -> Return unique sets that sum to 0
    */

    public List<List<Integer>> fourSumBruteForce(int[] nums, int target) {
        int n = nums.length;
        Set<List<Integer>> result = new HashSet<>();

        // Try all combinations of four distinct indices
        for (int i = 0; i < n - 3; i++) {
            for (int j = i + 1; j < n - 2; j++) {
                for (int k = j + 1; k < n - 1; k++) {
                    for (int l = k + 1; l < n; l++) {

                        // Use long to avoid integer overflow
                        long sum = (long) nums[i] + nums[j] + nums[k] + nums[l];

                        if (sum == target) {
                            /* Sort the quadruplet before storing to ensure uniqueness
                             * Example: [0, 1, -1, 0] -> [-1, 0, 0, 1]
                             */
                            List<Integer> quad = Arrays.asList(nums[i], nums[j], nums[k], nums[l]);
                            Collections.sort(quad);
                            result.add(quad);
                        }
                    }
                }
            }
        }

        return new ArrayList<>(result);  // Convert HashSet to List
    }

    // ---------------------------------------------------
    // ðŸ”¶ APPROACH 2: SORT + TWO POINTERS (Optimized)
    // ---------------------------------------------------
    /*
    ðŸ”¸ Time Complexity: O(N^3) â€” Two nested loops + two pointers  
    ðŸ”¸ Space Complexity: O(K) â€” K = number of unique quadruplets (for HashSet)

    ðŸ”¸ How It Works:
    - Sort the array to make duplicate checking and two-pointer logic easier.
    - Use two nested loops to fix the first two numbers.
    - Use a two-pointer strategy to find remaining two numbers efficiently.

    ðŸ”¸ Dry Run:
    Input: nums = [1, 0, -1, 0, -2, 2], target = 0  
    Sorted: [-2, -1, 0, 0, 1, 2]  
    Loop i=-2, j=-1 â†’ Use two pointers on [0, 0, 1, 2]
    Valid sums found: [-2, -1, 1, 2], etc.
    */

    public List<List<Integer>> fourSum(int[] nums, int target) {
        int n = nums.length;
        Set<List<Integer>> result = new HashSet<>();

        Arrays.sort(nums);  // Required for two-pointer and skipping duplicates

        for (int i = 0; i < n - 3; i++) {
            for (int j = i + 1; j < n - 2; j++) {

                int left = j + 1;
                int right = n - 1;

                // Two-pointer search between left and right
                while (left < right) {
                    /* Use long to prevent overflow */
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];

                    if (sum == target) {
                        /* Valid quadruplet found */
                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        left++;
                        right--;
                    } else if (sum < target) {
                        left++;  // Increase sum by moving left forward
                    } else {
                        right--; // Decrease sum by moving right backward
                    }
                }
            }
        }

        return new ArrayList<>(result);  // Convert set to list
    }

    // ---------------------------------------------------
    // ðŸ”½ Sample Main Method for Testing
    // ---------------------------------------------------
    public static void main(String[] args) {
        Solution sol = new Solution();
        int[] nums = {1, 0, -1, 0, -2, 2};
        int target = 0;

        // Choose either of the methods below to test
        System.out.println("Brute Force: " + sol.fourSumBruteForce(nums, target));
        System.out.println("Optimized: " + sol.fourSum(nums, target));
    }
}
