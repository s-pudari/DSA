/*
Problem: Smallest Divisor Given a Threshold
Link: https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/

Problem statement (in my words):
------------------------------------------------
We are given an integer array `nums` and an integer `threshold`.
We need to find the smallest integer `d` such that:
   sum( ceil(nums[i] / d) ) <= threshold
Return this divisor.

------------------------------------------------
We’ll solve this using multiple approaches:
  1. Brute Force Linear Search
  2. Optimized Binary Search
------------------------------------------------
*/


class Solution {

    /* ================================================================
       APPROACH 1 — BRUTE FORCE (Linear Search)
       ----------------------------------------------------------------
       Explanation:
       - Try every possible divisor from 1 up to max(nums).
       - For each divisor, compute sum(ceil(nums[i]/divisor)).
       - If the sum <= threshold → return that divisor.
       - This works but is slow for large arrays.

       Time Complexity: O(max(nums) * n)
       Space Complexity: O(1).

       Dry Run:
       nums = [1,2,5,9], threshold = 6
       max(nums) = 9
       divisor = 1 → sum = 1+2+5+9 = 17 > 6 → not valid
       divisor = 2 → sum = 1+1+3+5 = 10 > 6
       divisor = 3 → sum = 1+1+2+3 = 7 > 6
       divisor = 4 → sum = 1+1+2+3 = 7 > 6
       divisor = 5 → sum = 1+1+1+2 = 5 ≤ 6 → answer = 5
    ================================================================ */
    public int smallestDivisorBrute(int[] nums, int threshold) {
        int maxVal = 0;
        for (int num : nums) {
            maxVal = Math.max(maxVal, num);
        }

        for (int d = 1; d <= maxVal; d++) {
            int sum = 0;
            for (int num : nums) {
                sum += (num + d - 1) / d; // ceil division
            }
            if (sum <= threshold) {
                return d;
            }
        }
        return maxVal;
    }



    /* ================================================================
       APPROACH 2 — OPTIMIZED (Binary Search)
       ----------------------------------------------------------------
       Explanation:
       - The divisor must lie between 1 and max(nums).
       - Use binary search to minimize divisor:
         * mid = (low+high)/2
         * If mid is valid (sum <= threshold) → shrink range (move left).
         * Else → move right.
       - At the end, `low` will hold the smallest valid divisor.

       Time Complexity: O(n log(max(nums)))
       Space Complexity: O(1).

       Dry Run:
       nums = [1,2,5,9], threshold = 6
       max(nums) = 9
       low = 1, high = 9
         mid = 5 → sum = (1/5)+(2/5)+(5/5)+(9/5)=1+1+1+2=5 ≤ 6 → valid, move left
         low = 1, high = 4
         mid = 2 → sum = 1+1+3+5=10 > 6 → invalid, move right
         low = 3, high = 4
         mid = 3 → sum = 1+1+2+3=7 > 6 → invalid
         low = 4, high = 4
         mid = 4 → sum = 1+1+2+3=7 > 6 → invalid
         low = 5, high = 4 → loop ends
       Answer = 5
    ================================================================ */
    public int smallestDivisor(int[] nums, int threshold) {
        int maxVal = 0;
        for (int num : nums) {
            maxVal = Math.max(maxVal, num);
        }

        int low = 1, high = maxVal;
        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (isValid(nums, threshold, mid)) {
                high = mid - 1; // try smaller divisor
            } else {
                low = mid + 1; // need bigger divisor
            }
        }
        return low;
    }

    // Helper function: check if divisor `d` satisfies condition
    private boolean isValid(int[] nums, int threshold, int d) {
        int sum = 0;
        for (int num : nums) {
            sum += (num + d - 1) / d; // ceil division
        }
        return sum <= threshold;
    }


    /* ================================================================
       SUMMARY:
       - Approach 1 (Brute Force): O(n * max(nums)), impractical for large input.
       - Approach 2 (Binary Search): O(n log(max(nums))), best for constraints.
    ================================================================ */
}
