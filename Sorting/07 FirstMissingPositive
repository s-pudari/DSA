/*
 Problem: First Missing Positive
 LeetCode Link: https://leetcode.com/problems/first-missing-positive/

 Description:
  You're given an unsorted integer array. Your goal is to find the smallest missing positive integer.
  You must do this in O(n) time and use constant extra space.

 Approach 1: Brute Force Using HashSet
 -------------------------------------
 Steps:
 1. Insert all numbers into a HashSet for constant-time lookups.
 2. Iterate from 1 to n (inclusive) and return the first number not in the set.
 3. If all numbers from 1 to n are present, return n + 1.

 Dry Run Example:
  Input: [3, 4, -1, 1]
  HashSet = {3,4,-1,1}
  Check 1 → exists
  Check 2 → missing → return 2

 Time Complexity: O(n)
 Space Complexity: O(n) — due to HashSet usage
*/

class SolutionBrute {
    public int firstMissingPositive(int[] nums) {
        Set<Integer> seen = new HashSet<>();
        for (int num : nums) seen.add(num);

        for (int i = 1; i <= nums.length; i++) {
            if (!seen.contains(i)) return i;
        }
        return nums.length + 1;
    }
}

/*
 Approach 2: Optimized (Cycle Sort Technique)
 ---------------------------------------------
 Idea:
  - Place each positive integer x (1 ≤ x ≤ n) at index x - 1.
  - After rearrangement, the first index where nums[i] != i + 1 gives the missing number at i + 1.

 Strong Points:
  - In-place rearrangement.
  - Constant extra space.

 Detailed Dry Run:
  Input: [3, 4, -1, 1]
  Steps:
   1. i = 0 → nums[0]=3 → correct pos=2 → swap nums[0] & nums[2] → [ -1, 4, 3, 1 ]
   2. i = 0 → nums[0] = -1 (ignored, out of valid range) → increment i
   3. i = 1 → nums[1] = 4 → correct pos = 3 → swap → [ -1, 1, 3, 4 ]
   4. i = 1 → nums[1] = 1 → correct pos = 0 → swap → [ 1, -1, 3, 4 ]
   5. All further are either in place or ignored
  Final array: [1, -1, 3, 4]
  Walk through:
   - i = 0 → 1 → OK
   - i = 1 → -1 != 2 → return 2

 Time Complexity: O(n)
 Space Complexity: O(1)
*/

class Solution {
    public int firstMissingPositive(int[] nums) {
        cycleSort(nums);

        // Identify the first index where the number is incorrect
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }

        // If all are correctly placed, the missing number is n+1
        return nums.length + 1;
    }

    /**
     * Rearranges the array in-place so each number is placed at index = value - 1 (if valid).
     */
    private void cycleSort(int[] nums) {
        int i = 0;
        while (i < nums.length) {
            int current = nums[i];
            int correctIndex = current - 1;

            // Swap only when in valid range and not already in correct position
            if (current > 0 && current <= nums.length && nums[i] != nums[correctIndex]) {
                swap(nums, i, correctIndex);
            } else {
                // Move forward if invalid or already in correct position
                i++;
            }
        }
    }

    /** Swaps elements at indices a and b */
    private void swap(int[] nums, int a, int b) {
        int tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
}
