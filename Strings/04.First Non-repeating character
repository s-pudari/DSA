/*
ðŸ”¥ PROBLEM STATEMENT ðŸ”¥
-----------------------
Given a lowercase string `s`, return the **first non-repeating character** in it.
If there's no such character, return `'$'`.

Examples:
----------
âœ… Input : s = "geeksforgeeks"
âœ… Output: 'f'

âœ… Input : s = "aabb"
âœ… Output: '$' (all characters repeat)

---

ðŸ’¡ APPROACH OVERVIEW ðŸ’¡
=======================

âœ… Optimized Approach (Using Indexed Frequency Array):
------------------------------------------------------
- Use a fixed-size array `vis[26]` to track **indexes of first appearances**.
- Mark:
  - `-1` if character **hasnâ€™t appeared yet**
  - `index` of first occurrence
  - `-2` if character **appears more than once**
- Traverse the array to find the **smallest non -1 and non -2 index**.

ðŸ•’ Time Complexity : O(n + 26) â†’ **O(n)**
ðŸ§  Space Complexity: O(1) â†’ fixed array size for 26 lowercase letters

âœ… Brute-Force Approach (Commented Below):
------------------------------------------
- For each character, check if it appears again in the string.
- Return the **first one that doesnâ€™t**.

ðŸ•’ Time Complexity : O(nÂ²)
ðŸ§  Space Complexity: O(1)

---

ðŸ” Dry Run Example:
-------------------
Input: "geeksforgeeks"

1st Pass:
----------
vis = [gâ†’0, eâ†’-2, kâ†’5, sâ†’6, fâ†’7, oâ†’8, râ†’9]
(after tracking first and repeated indices)

2nd Pass:
----------
Smallest index in vis[] with value >= 0 is 7 ('f')

âœ… Output: 'f'
*/

import java.util.*;

class Solution {
    static char nonRepeatingChar(String s) {

        int max = 26; // Only lowercase letters a-z
        int[] vis = new int[max]; // Index of first appearance or repeated flag
        Arrays.fill(vis, -1); // -1 means not seen yet

        // Step 1: Mark the first or repeated occurrence of each character
        for (int i = 0; i < s.length(); i++) {
            int idx = s.charAt(i) - 'a'; // Convert 'a'..'z' to 0..25

            if (vis[idx] == -1) {
                // First time we see this character, store its index
                vis[idx] = i;
            } else {
                // Character has already appeared â†’ mark as repeated
                vis[idx] = -2;
            }
        }

        int minIndex = -1;

        // Step 2: Find the smallest index of any non-repeating character
        for (int i = 0; i < max; i++) {
            /* 
            We're looking for:
            - Characters that appeared only once â†’ vis[i] >= 0
            - And among those, the one with the **smallest index**
            */
            if (vis[i] >= 0 && (minIndex == -1 || vis[i] < vis[minIndex])) {
                minIndex = i;
            }
        }

        // Step 3: Return result
        return minIndex == -1 ? '$' : s.charAt(vis[minIndex]);
    }
}


/*
ðŸ’­ BRUTE-FORCE APPROACH (Commented Below)
=========================================

This method checks each character manually for repeats.

static char nonRepeatingChar(String s) {
    int n = s.length();

    for (int i = 0; i < n; i++) {
        char ch = s.charAt(i);
        boolean found = false;

        for (int j = 0; j < n; j++) {
            // Skip checking the character against itself
            if (i != j && ch == s.charAt(j)) {
                found = true; // Duplicate found
                break;
            }
        }

        // If no duplicates found, this is our answer
        if (!found) {
            return ch;
        }
    }

    // If all characters repeat
    return '$';
}

âš ï¸ Why this is inefficient?
----------------------------
- Nested loops â†’ O(nÂ²) time â†’ slow for large strings
- Better to use character tracking with extra space (like vis[] array)
*/
