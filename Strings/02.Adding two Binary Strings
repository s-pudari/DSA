https://www.geeksforgeeks.org/batch/gfg-160-problems/track/string-gfg-160/problem/add-binary-strings3805
/*
Problem:
---------
Given two binary strings `s1` and `s2`, return their sum as a binary string.

For example:
Input: s1 = "1010", s2 = "1011"
Output: "10101"
Explanation: 1010 (10) + 1011 (11) = 10101 (21)

Goal:
-----
Simulate binary addition (like how we do in decimal) but for base-2.

Approach Overview:
===================

Optimized Approach:
--------------------
- Traverse both strings from right to left, adding corresponding bits and keeping track of the carry.
- Use a StringBuilder to build the result.
- If one string is shorter, treat the missing bits as '0'.
- Time Complexity: O(max(n, m)) — because we traverse the longer of the two strings once.
- Space Complexity: O(max(n, m)) — for storing the result in a StringBuilder.

Brute-force Approach (Commented Below):
---------------------------------------
- Convert binary strings to decimal using `Integer.parseInt(s, 2)`
- Add the two integers.
- Convert the sum back to binary using `Integer.toBinaryString()`.
- Time Complexity: O(n + m), but constrained by integer overflow (not suitable for very large inputs).
- Space Complexity: O(1) for logic, but not safe for large binaries due to int size limits.

Dry Run Example (Optimized):
-----------------------------
s1 = "1010"
s2 = "1011"

Right to left:
i=3: 0 (from s1) + 1 (from s2) + 0 (carry) = 1 → result = "1", carry = 0
i=2: 1 + 1 + 0 = 2 → result = "0", carry = 1
i=1: 0 + 0 + 1 = 1 → result = "01", carry = 0
i=0: 1 + 1 + 0 = 2 → result = "001", carry = 1

Append carry → result = "1001", then reverse → "10100"

Strip leading zeros if any (not applicable here).
Final output = "10101"
*/

class Solution {
    public String addBinary(String s1, String s2) {

        // Step 1: Ensure s1 is the longer string (to simplify logic)
        int n = s1.length();
        int m = s2.length();

        if (n < m) {
            // Swap to make sure s1 is always longer or equal in length
            String temp = s1;
            s1 = s2;
            s2 = temp;

            int tempLen = n;
            n = m;
            m = tempLen;
        }

        int carry = 0; // Initialize carry
        StringBuilder result = new StringBuilder(); // To build the binary result
        int j = m - 1; // Pointer for s2 (shorter string)

        // Step 2: Traverse s1 from right to left
        for (int i = n - 1; i >= 0; i--) {
            int bit1 = s1.charAt(i) - '0'; // Convert char to int (e.g., '1' → 1)
            int bitSum = bit1 + carry;     // Add carry from previous step

            if (j >= 0) {
                int bit2 = s2.charAt(j) - '0'; // Only add from s2 if index is valid
                bitSum += bit2;
                j--;
            }

            int bit = bitSum % 2;  // If sum is 0 or 2 → 0; if 1 or 3 → 1
            carry = bitSum / 2;    // Carry is 1 if sum >= 2
            result.append(bit);   // Append current bit to result
        }

        // Step 3: If there's any carry left, append it
        if (carry > 0) {
            result.append(carry);
        }

        // Step 4: Reverse the result since we built it backwards
        String finalRes = result.reverse().toString();

        // Step 5: Remove leading zeros
        int idx = 0;
        while (idx < finalRes.length() && finalRes.charAt(idx) == '0') {
            idx++;
        }

        // If entire result was zeros (e.g., "0000"), return "0"
        return (idx == finalRes.length()) ? "0" : finalRes.substring(idx);
    }
}


/*
===============================================================
Brute-force Approach (only for small binary strings)
===============================================================

public String addBinary(String s1, String s2) {
    
    // Note: This approach uses built-in conversion functions.
    // It will fail for very large binary strings due to overflow limits of int/long.

    // Step 1: Convert binary strings to decimal integers
    int num1 = Integer.parseInt(s1, 2);  // "1010" → 10
    int num2 = Integer.parseInt(s2, 2);  // "1011" → 11

    // Step 2: Add the two integers
    int sum = num1 + num2;              // 10 + 11 = 21

    // Step 3: Convert sum back to binary string
    return Integer.toBinaryString(sum); // 21 → "10101"
}

Why not preferred?
------------------
• Limited to 32-bit/64-bit integer range.
• Fails for very large binary strings (like 1000-bit numbers).
• Optimized solution handles arbitrarily large inputs without overflow.
*/
