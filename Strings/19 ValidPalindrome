/*
Problem: Valid Palindrome
Link: https://leetcode.com/problems/valid-palindrome/

Brief Problem Explanation:
- A string is a palindrome if, after converting all uppercase letters into lowercase letters 
  and removing all non-alphanumeric characters, it reads the same forward and backward.
- Return true if it is a palindrome, otherwise return false.

Weâ€™ll cover two approaches:
1. Brute Force: Clean the string and reverse it to check equality.
2. Optimized Two-Pointer: Compare characters from both ends moving inward.
*/

class Solution {

    /*
    --------------------------------------------------------
    APPROACH 1 â€” Brute Force (reverse and compare)
    --------------------------------------------------------
    Time Complexity: O(n) for cleaning + O(n) for reversing â†’ O(n)
    Space Complexity: O(n) for storing cleaned string.

    Explanation:
    - Convert string to lowercase and remove non-alphanumeric characters.
    - Reverse the cleaned string.
    - Compare cleaned string with its reverse.

    Dry Run:
      s = "A man, a plan, a canal: Panama"
      Cleaned = "amanaplanacanalpanama"
      Reverse = "amanaplanacanalpanama"
      Both equal â†’ return true
    */
    public boolean isPalindromeBruteForce(String s) {
        // Step 1: Clean the string
        s = s.toLowerCase();
        s = s.replaceAll("[^a-zA-Z0-9]", "");

        // Step 2: Reverse the cleaned string
        String reversed = new StringBuilder(s).reverse().toString();

        // Step 3: Compare with reversed
        return s.equals(reversed);
    }
    
/*-----------------------------------------------------
//Approach-2 
-------------------------------------------------------
ðŸ“Š Complexity:
- Time: O(n) â†’ scanning string once with two pointers.
- Space: O(1) â†’ only pointers used, no extra data structure.

---------------------------------------------------------
ðŸ§ª Dry Run Example:
Input: "A man, a plan, a canal: Panama"

i=0 â†’ 'A' â†’ lowercase 'a'  
j=29 â†’ 'a' â†’ lowercase 'a' (match âœ…)  

i=1 â†’ ' ' (skip non-alphanumeric)  
i=2 â†’ 'm'  
j=28 â†’ 'm' (match âœ…)  

... (continues checking inward) ...  
Final Result: true

---------------------------------------------------------
ðŸš€ Brute Force Approach (Commented Out):
// 1. Build a cleaned string manually by appending only alphanumeric chars
//    and converting them to lowercase.
// 2. Compare this cleaned string with its reverse.
// 3. If equal â†’ return true, else false.
// Drawback: Extra O(n) space and reverse operation.

---------------------------------------------------------
âœ… Optimized Code (Two Pointers, Manual Checks)
*/

class Solution {
    public boolean isPalindrome(String s) {
        int i = 0, j = s.length() - 1;

        while (i < j) {
            char left = s.charAt(i);
            char right = s.charAt(j);

            /* Skip non-alphanumeric characters */
            if (!isAlphaNumeric(left)) {
                i++;
                continue;
            }
            if (!isAlphaNumeric(right)) {
                j--;
                continue;
            }

            /* Convert both chars to lowercase manually */
            left = toLowerCase(left);
            right = toLowerCase(right);

            /* Compare characters */
            if (left != right) {
                return false; // mismatch â†’ not palindrome
            }

            i++;
            j--;
        }
        return true; // all checks passed
    }

    /* Check if character is alphanumeric */
    private boolean isAlphaNumeric(char ch) {
        return (ch >= '0' && ch <= '9') || 
               (ch >= 'A' && ch <= 'Z') || 
               (ch >= 'a' && ch <= 'z');
    }

    /* Convert uppercase letter to lowercase manually */
    private char toLowerCase(char ch) {
        if (ch >= 'A' && ch <= 'Z') {
            return (char)(ch + 32); // ASCII difference
        }
        return ch; // already lowercase or digit
    }
}
    /*
    --------------------------------------------------------
    APPROACH 3 â€” Optimized Two-Pointer
    --------------------------------------------------------
    Time Complexity: O(n)
    Space Complexity: O(1)

    Explanation:
    - Convert string to lowercase and remove non-alphanumeric characters.
    - Use two pointers: one at the start, one at the end.
    - Move inward while comparing characters.
    - If mismatch occurs â†’ return false.
    - If loop completes â†’ return true.

    Dry Run:
      s = "race a car"
      Cleaned = "raceacar"
      Compare r vs r â†’ ok
      Compare a vs a â†’ ok
      Compare c vs c â†’ ok
      Compare e vs a â†’ mismatch â†’ return false
    */
    public boolean isPalindrome(String s) {
        // Step 1: Clean string
        s = s.toLowerCase();
        s = s.replaceAll("[^a-zA-Z0-9]", "");

        // Step 2: Initialize two pointers
        int i = 0, j = s.length() - 1;

        // Step 3: Compare while moving inward
        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }
        return true;
    }
}
