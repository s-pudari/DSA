//https://leetcode.com/problems/count-and-say/
/*
📌 PROBLEM: Count and Say (Leetcode 38)
---------------------------------------
You are given an integer `n`. Your task is to generate the nth term in the **Count and Say** sequence.

👉 The "Count and Say" sequence is defined as:
    1. 1             (one 1 → "11")
    2. 11            (two 1s → "21")
    3. 21            (one 2, one 1 → "1211")
    4. 1211          (one 1, one 2, two 1s → "111221")
    5. 111221        (three 1s, two 2s, one 1 → "312211")
    ...
    - Each term is generated by describing the **previous term**, counting the number of times each digit appears **consecutively**.

---------------------------------------------------
💡 OPTIMIZED APPROACH (Greedy Build from Previous Term):
---------------------------------------------------
1. Start with "1".
2. For each level `i` from 2 to n:
   - Read the previous string.
   - Count consecutive identical digits and build the next string.

🕒 Time Complexity: O(N * M)  
    - N: number of iterations  
    - M: average string length (roughly doubles every few steps)

🧠 Space Complexity: O(M)  
    - For temporary string construction at each level

📌 DRY RUN for n = 4:
----------------------
n = 1 → "1"  
n = 2 → one 1 → "11"  
n = 3 → two 1s → "21"  
n = 4 → one 2, one 1 → "1211" ✅

*/

class Solution {
    public String countAndSay(int n) {
        // Base case: The first term of the sequence is always "1"
        String sb = "1";

        // Loop to build the sequence from 2 to n
        for (int i = 2; i <= n; i++) {
            StringBuilder temp = new StringBuilder(); // To build the current term
            int cnt = 1; // Count of repeating digits

            // Traverse current string (sb) to build the next term
            for (int j = 1; j < sb.length(); j++) {
                // If current char is same as previous, increase count
                if (sb.charAt(j) == sb.charAt(j - 1)) {
                    cnt++;
                } else {
                    /*
                    If the current char is different:
                    - Append the count and the previous character to temp
                    - Reset the count for new character
                    */
                    temp.append(cnt).append(sb.charAt(j - 1));
                    cnt = 1;
                }
            }

            // Don't forget to append the last sequence group!
            temp.append(cnt).append(sb.charAt(sb.length() - 1));

            // Update sb to the newly constructed term for next iteration
            sb = temp.toString();
        }

        return sb; // Final term after n iterations
    }


    /*
    -------------------------------------
    ❌ BRUTE-FORCE STYLE APPROACH (NOT OPTIMAL)
    -------------------------------------
    Idea:
    - Store all intermediate terms in a list up to n
    - At each step, describe the previous string and store it in list
    - More memory intensive and unnecessary for just nth term

    🕒 Time Complexity: O(N * M)
    🧠 Space Complexity: O(N * M) */

    String countAndSay(int n) {
        List<String> sequence = new ArrayList<>();
        sequence.add("1"); // First term

        for (int i = 1; i < n; i++) {
            String prev = sequence.get(i - 1);
            StringBuilder current = new StringBuilder();
            int count = 1;

            for (int j = 1; j < prev.length(); j++) {
                if (prev.charAt(j) == prev.charAt(j - 1)) {
                    count++;
                } else {
                    current.append(count).append(prev.charAt(j - 1));
                    count = 1;
                }
            }

            // Append the last group of characters
            current.append(count).append(prev.charAt(prev.length() - 1));
            sequence.add(current.toString());
        }

        return sequence.get(n - 1);
    }
    
}
