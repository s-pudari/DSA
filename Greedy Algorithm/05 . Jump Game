https://leetcode.com/problems/jump-game/
/*
    ğŸ§  Problem Statement:
    You are given an array of non-negative integers `nums`, where each element represents your maximum jump length at that position.
    Return `true` if you can reach the last index starting from index 0, otherwise return `false`.

    Example:
    Input: nums = [2,3,1,1,4]
    Output: true
    Explanation: 
      - Start at index 0 (value = 2) â†’ can jump to index 1 or 2
      - From index 1 (value = 3) â†’ can reach index 4 (the end)

    ğŸš€ Optimized Approach: Greedy
    â¤ Idea: Track the farthest index we can reach while iterating.
    â¤ If at any point the current index is greater than the farthest reachable index, return false.

    Time Complexity: O(n)
    Space Complexity: O(1)

    Dry Run:
    Input: nums = [2,3,1,1,4]
    maxReach = 0
    i = 0 â†’ maxReach = max(0, 0+2) = 2
    i = 1 â†’ maxReach = max(2, 1+3) = 4
    i = 2 â†’ maxReach = max(4, 2+1) = 4
    i = 3 â†’ maxReach = max(4, 3+1) = 4
    i = 4 â†’ maxReach = max(4, 4+4) = 8
    Since we completed the loop, return true
*/

class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;

        int maxIndex = 0; // farthest index we can currently reach

        for (int i = 0; i < n; i++) {
            // ğŸ›‘ If the current index is beyond the farthest reachable index, we can't move further
            if (i > maxIndex) return false;

            // âœ… Update the farthest reachable index from this position
            maxIndex = Math.max(maxIndex, i + nums[i]);
        }

        // If we successfully loop through the array, it means we can reach the end
        return true;
    }

    /*
        ğŸ’¡ Brute-force Approach: Recursion (Backtracking)
        â¤ Try every jump possible from each index.
        â¤ For each index, recursively check if any jump can reach the last index.

        Time Complexity: O(2^n) â€” Exponential in the worst case
        Space Complexity: O(n) â€” Due to recursive call stack

        Dry Run:
        nums = [2,3,1,1,4]
        Start at index 0 â†’ jump 1 to index 1 â†’ jump 3 to index 4 â†’ reached!
        OR â†’ jump 2 to index 2 â†’ jump 1 to index 3 â†’ jump 1 to index 4 â†’ reached!

        Code:
    
        public boolean canJump(int[] nums) {
            return canReach(nums, 0);
        }

        private boolean canReach(int[] nums, int pos) {
            int n = nums.length;
            
            // âœ… Base case: if we reached or passed the last index
            if (pos >= n - 1) return true;

            int maxJump = nums[pos];

            // ğŸ” Try every possible jump length from 1 to maxJump
            for (int jump = 1; jump <= maxJump; jump++) {
                if (canReach(nums, pos + jump)) {
                    return true;
                }
            }

            // âŒ If none of the jumps work, return false
            return false;
        }
    */
}
