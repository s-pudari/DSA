/*
Question: N Meetings in One Room (Greedy - Classic Interview Problem)

ğŸ§  Problem Statement:
----------------------
Given `n` meetings with their start and end times, schedule the **maximum number of non-overlapping meetings** that can be conducted in one room.
Return the list of meeting indices (1-based) in the order they were selected.

---
âœ… Optimized Approach: Greedy
------------------------------
1. Store meetings as a triplet (start, end, index).
2. Sort all meetings by their end time.
3. Always pick the earliest finishing meeting that doesn't overlap with the previously selected one.

ğŸ“ˆ Time Complexity: O(N log N) â€” for sorting  
ğŸ“¦ Space Complexity: O(N) â€” for storing meeting data

---
âŒ Brute-force Approach (Not implemented here):
-----------------------------------------------
- Try all possible subsets of non-overlapping meetings â†’ Exponential time (2^N).
- Highly inefficient, not practical for large N.

---
ğŸ“Š Dry Run:
Input:
start = [1, 3, 0, 5, 8, 5]
end   = [2, 4, 6, 7, 9, 9]

Step 1: Pair and sort by end time â†’
Meetings: (1,2,1), (3,4,2), (0,6,3), (5,7,4), (5,9,6), (8,9,5)

Step 2: Pick meeting 1 (1,2) â†’ lastEndTime = 2  
        Pick meeting 2 (3,4) â†’ lastEndTime = 4  
        Skip meeting 3 (0,6) â†’ starts before 4  
        Pick meeting 4 (5,7) â†’ lastEndTime = 7  
        Skip meeting 6 (5,9) â†’ starts before 7  
        Pick meeting 5 (8,9) â†’ lastEndTime = 9

Output: [1, 2, 4, 5] â€” Max 4 meetings
---
*/

import java.util.*;

class Solution {

    // Internal class to store meeting data
    static class Meeting {
        int start, end, index;

        Meeting(int s, int e, int i) {
            start = s;
            end = e;
            index = i; // Store the original 1-based index
        }
    }

    public static List<Integer> maxMeetings(int[] start, int[] end) {
        int n = start.length;
        List<Meeting> meetings = new ArrayList<>();

        // Step 1: Pair start, end, and index into Meeting objects
        for (int i = 0; i < n; i++) {
            meetings.add(new Meeting(start[i], end[i], i + 1)); // i+1 for 1-based indexing
        }

        // Step 2: Sort meetings based on their end times (greedy choice)
        meetings.sort((a, b) -> a.end - b.end);

        List<Integer> result = new ArrayList<>();
        int lastEndTime = 0; // Keeps track of end time of last selected meeting

        // Step 3: Iterate and select non-overlapping meetings
        for (Meeting m : meetings) {
            if (m.start > lastEndTime) {
                /* 
                Only select this meeting if it starts after the last one ended.
                Ensures no overlapping.
                */
                result.add(m.index);
                lastEndTime = m.end; // Update lastEndTime
            }
        }

        return result; // List of selected meeting indices
    }

    // Sample usage
    public static void main(String[] args) {
        int[] start = {1, 3, 0, 5, 8, 5};
        int[] end   = {2, 4, 6, 7, 9, 9};

        List<Integer> order = maxMeetings(start, end);
        System.out.println("Maximum number of meetings: " + order.size());
        System.out.print("Order of meetings: ");
        for (int idx : order) {
            System.out.print(idx + " ");
        }
    }
}
