/*
ðŸ”¥ PROBLEM: Fruit Into Baskets (Max Fruits in 2 Types) ðŸ”¥
---------------------------------------------------------
Link: https://leetcode.com/problems/fruit-into-baskets/

Given an integer array `fruits` where `fruits[i]` is the type of fruit
on the i-th tree, you want to collect fruits in baskets. Each basket
can only hold one type of fruit and you have only **two** baskets.
Return the maximum number of fruits you can collect in total by
choosing a contiguous subarray that contains at most two different types.

Example:
fruits = [1,2,1] â†’ answer = 3 (take whole array)
fruits = [0,1,2,2] â†’ answer = 3 (take [2,2] or [1,2,2])

---

ðŸ”Ž BRUTE-FORCE APPROACH
------------------------
ðŸ’¡ Idea:
- For each start index i, expand j to the right and track distinct fruit types
  (with a HashSet). Stop expanding when distinct types > 2.
- Track the longest valid window length found.
- Simple and easy to reason about, but O(nÂ²) in worst-case.

ðŸ•’ Time Complexity: O(nÂ²)  
ðŸ§  Space Complexity: O(n) for HashSet (worst-case)

ðŸ” Dry Run (fruits = [1,2,1,2,3]):
i=0:
 - j=0 â†’ set={1} â†’ len=1
 - j=1 â†’ set={1,2} â†’ len=2
 - j=2 â†’ set={1,2} â†’ len=3
 - j=3 â†’ set={1,2} â†’ len=4
 - j=4 â†’ set={1,2,3} -> stop
max so far = 4

Code (Brute-force):
-------*/
public int totalFruitBruteForce(int[] fruits) {
    int n = fruits.length;
    int ans = 0;

    for (int i = 0; i < n; i++) {
        HashSet<Integer> hs = new HashSet<>(); // distinct fruit types in window
        for (int j = i; j < n; j++) {
            hs.add(fruits[j]); // include fruit at j
            if (hs.size() <= 2) {
                ans = Math.max(ans, j - i + 1); // valid window
            } else {
                break; // more than 2 types â†’ no need to extend this i
            }
        }
    }
    return ans;
}

/*----------------------------------------------

âœ… OPTIMIZED APPROACH: Sliding Window (HashMap)
-----------------------------------------------
ðŸ’¡ Idea:
- Use sliding window [l..r] and a HashMap `hm` that maps fruit type â†’ count in window.
- Expand `r` and increment count of fruits[r].
- While `hm.size() > 2` (more than 2 types), shrink window from left:
    - decrement count of fruits[l], remove from map if count becomes 0, then l++.
- At each step update `ans = max(ans, r - l + 1)`.
- Each index is processed at most twice â†’ O(n) time.

ðŸ•’ Time Complexity: O(n)  
ðŸ§  Space Complexity: O(1) (map size â‰¤ 3 actually; practically O(1)), or O(min(n, distinct types))

ðŸ” Dry Run (fruits = [1,2,1,2,3]):
Start: l=0,r=0,hm={}
r=0 â†’ add 1 â†’ hm={1:1} â†’ ans=1
r=1 â†’ add 2 â†’ hm={1:1,2:1} â†’ ans=2
r=2 â†’ add 1 â†’ hm={1:2,2:1} â†’ ans=3
r=3 â†’ add 2 â†’ hm={1:2,2:2} â†’ ans=4
r=4 â†’ add 3 â†’ hm={1:2,2:2,3:1} â†’ hm.size()>2 â†’ shrink:
    l=0 remove 1 â†’ hm={1:1,2:2,3:1} â†’ still size 3 â†’ l=1
    l=1 remove 2 â†’ hm={1:1,2:1,3:1} â†’ still size 3 â†’ l=2
    l=2 remove 1 â†’ hm={2:1,3:1} â†’ size 2 â†’ stop
Window now [l=3..r=4] length=2 â†’ ans remains 4
End â†’ answer = 4

Code (Optimized):
-------*/
class Solution {
    public int totalFruit(int[] fruits) {
        int l = 0, r = 0;                // sliding window boundaries
        int n = fruits.length;
        int ans = 0;                     // maximum fruits collected
        HashMap<Integer, Integer> hm = new HashMap<>(); // fruitType -> count in window

        while (r < n) {
            // include fruits[r] into the window and update count
            hm.put(fruits[r], hm.getOrDefault(fruits[r], 0) + 1);

            // if more than 2 distinct fruit types, shrink from left
            while (hm.size() > 2) {
                int lval = fruits[l];            // fruit type at left
                hm.put(lval, hm.get(lval) - 1);  // decrement its count
                if (hm.get(lval) == 0) {
                    hm.remove(lval);             // remove type if count becomes 0
                }
                l++;                             // shrink window from left
            }

            // current window [l..r] is valid (<= 2 types) â†’ update answer
            ans = Math.max(ans, r - l + 1);

            r++; // expand window to the right
        }

        return ans;
    }
}

