/*
ğŸ”¥ PROBLEM: Trapping Rain Water ğŸ”¥
---------------------------------
Link: https://leetcode.com/problems/trapping-rain-water/

Given an array `arr` representing heights of bars, return how much
rainwater can be trapped between them.

Water trapped at index i depends on:
min(max height to the left, max height to the right) - arr[i]

---

ğŸ” APPROACH 1: Prefix & Suffix Max Arrays
------------------------------------------
ğŸ’¡ Idea:
- Create prefixMax[i] = max height from 0 â†’ i
- Create suffixMax[i] = max height from n-1 â†’ i
- Water at i = min(prefixMax[i], suffixMax[i]) - arr[i]
- Add for all i

ğŸ•’ Time Complexity: O(n)  
ğŸ§  Space Complexity: O(n)

ğŸ” Dry Run (arr = [0,1,0,2]):
prefixMax â†’ [0,1,1,2]  
suffixMax â†’ [2,2,2,2]

i=2 â†’ arr[2]=0  
water = min(1,2)-0 = 1

Code:
-------
public int trapPrefixSuffix(int[] arr) {
    int n = arr.length;
    int[] prefixMax = new int[n];

    prefixMax[0] = arr[0];
    for (int i = 1; i < n; i++) {
        prefixMax[i] = Math.max(prefixMax[i - 1], arr[i]);
    }

    int[] suffixMax = new int[n];
    suffixMax[n - 1] = arr[n - 1];

    for (int i = n - 2; i >= 0; i--) {  // fixed small bug: should go till i>=0
        suffixMax[i] = Math.max(suffixMax[i + 1], arr[i]);
    }

    int total = 0;

    for (int i = 0; i < n; i++) {
        total += Math.min(prefixMax[i], suffixMax[i]) - arr[i];
    }

    return total;
}

----------------------------------------------

âœ… APPROACH 2: Two-Pointer (Optimized)
--------------------------------------
ğŸ’¡ Idea:
- Maintain two pointers `l` and `r`.
- Maintain `lmax` and `rmax`.
- Water can be trapped from the side with the smaller boundary.
- Move pointers inward while accumulating trapped water.

ğŸ•’ Time Complexity: O(n)  
ğŸ§  Space Complexity: O(1)

ğŸ” Dry Run (arr = [0,1,0,2]):
l=0,r=3 â†’ arr[l]=0 <= arr[r]=2 â†’ update lmax=0  
l=1 â†’ arr[l]=1 <= 2 â†’ update lmax=1  
l=2 â†’ arr[l]=0 <= 2 â†’ total += 1  
Final answer = 1

Code:
-------
class Solution {
    public int trap(int[] arr) {
        int l = 0, r = arr.length - 1;
        int lmax = 0, rmax = 0, total = 0;

        while (l < r) {
            if (arr[l] <= arr[r]) {
                if (lmax > arr[l]) {
                    total += lmax - arr[l];
                } else {
                    lmax = arr[l];
                }
                l++;
            } else {
                if (rmax > arr[r]) {
                    total += rmax - arr[r];
                } else {
                    rmax = arr[r];
                }
                r--;
            }
        }
        return total;
    }
}
*/
