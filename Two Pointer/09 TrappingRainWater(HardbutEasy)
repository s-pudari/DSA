/*
ğŸ”¥ PROBLEM: Trapping Rain Water  
---------------------------------
Link: https://leetcode.com/problems/trapping-rain-water/

Given an array `arr` representing elevation heights, compute how much
rainwater can be trapped between the bars.

A bar can trap water only if there are taller bars on both sides.
Water at index i = min(maxLeft, maxRight) - arr[i]

---

ğŸ” BRUTE-FORCE APPROACH  
------------------------
ğŸ’¡ Idea:
- For every index i:
  - Scan left to find left max (lmax)
  - Scan right to find right max (rmax)
- Add min(lmax, rmax) - arr[i] to total (if positive)

ğŸ•’ Time Complexity: O(nÂ²)  
ğŸ§  Space Complexity: O(1)

ğŸ” Dry Run (arr = [0,1,0,2]):
i = 2 â†’ arr[2] = 0  
lmax = 1 (from left), rmax = 2 (from right)  
Water = min(1,2) - 0 = 1  

Code:
-------*/
public int trapBruteForce(int[] arr) {
    int n = arr.length;
    if (n < 3) return 0;
    int total = 0;

    for (int i = 0; i < n; i++) {
        int lmax = 0, rmax = 0;

        for (int l = 0; l <= i; l++) {
            if (arr[l] > lmax) lmax = arr[l];
        }

        for (int r = i; r < n; r++) {
            if (arr[r] > rmax) rmax = arr[r];
        }

        total += Math.min(lmax, rmax) - arr[i];
    }

    return total;
}

/*----------------------------------------------

âœ… OPTIMIZED APPROACH: Two-Pointer  
----------------------------------
ğŸ’¡ Idea:
- Maintain two pointers: `l` from left, `r` from right.
- Maintain `lmax` and `rmax`.
- Always move the side with the smaller height.
- Accumulate trapped water directly.

ğŸ•’ Time Complexity: O(n)  
ğŸ§  Space Complexity: O(1)

ğŸ” Dry Run (arr = [0,1,0,2]):
l=0,r=3 â†’ arr[l]=0 <= arr[r]=2 â†’ update lmax=0  
l=1 â†’ arr[l]=1 <= 2 â†’ update lmax=1  
l=2 â†’ arr[l]=0 <= 2 â†’ water += 1  
Final total = 1

Code:
-------*/
class Solution {
    public int trap(int[] arr) {
        if (arr.length < 3) return 0;

        int l = 0, r = arr.length - 1;
        int lmax = 0, rmax = 0, total = 0;

        while (l < r) {
            if (arr[l] <= arr[r]) {
                if (lmax > arr[l]) {
                    total += lmax - arr[l];
                } else {
                    lmax = arr[l];
                }
                l++;
            } else {
                if (rmax > arr[r]) {
                    total += rmax - arr[r];
                } else {
                    rmax = arr[r];
                }
                r--;
            }
        }
        return total;
    }
}

