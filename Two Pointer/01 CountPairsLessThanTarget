/*
ğŸ¯ Problem Statement:
Given an integer array `arr[]` and a value `target`, return the **number of pairs** (i, j) such that:
- i < j
- arr[i] + arr[j] < target

We only need to **count** such pairs, not return the actual pairs.

--------------------------------------------------------------------------------------
ğŸ§  Brute-force Approach:

ğŸ”¸ Idea:
- Try every possible pair using two nested loops.
- If the sum of the pair is less than the target, increment the counter.

ğŸ“ˆ Time Complexity: O(nÂ²)  
ğŸ“¦ Space Complexity: O(1)

ğŸ§ª Dry Run Example:
arr = [1, 3, 5], target = 8

Possible pairs:
(1,3) = 4 âœ…  
(1,5) = 6 âœ…  
(3,5) = 8 âŒ

Total valid pairs = 2

ğŸ”§ Code:
*/
class Solution {
    int countPairs(int arr[], int target) {
        int n = arr.length;
        int cnt = 0;

        // Try all pairs (i, j) where i < j
        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                // Check if the sum is less than the target
                if (arr[i] + arr[j] < target) {
                    cnt++; // Valid pair found
                }
            }
        }

        return cnt; // Return total valid pairs
    }
}


/*
--------------------------------------------------------------------------------------
ğŸ§  Optimized Approach (Two Pointer - Applicable if Array is Sorted):

ğŸ”¸ Idea:
- First sort the array.
- Fix the `left` pointer at the beginning and `right` pointer at the end.
- If arr[left] + arr[right] < target:
   - All elements between left and right will form valid pairs with arr[left]
   - So we add (right - left) to count, and move `left` to the right.
- Otherwise, move `right` to the left.

ğŸ“ˆ Time Complexity: O(n log n) (due to sorting)  
ğŸ“¦ Space Complexity: O(1)

ğŸ§ª Dry Run Example:
arr = [1, 3, 5], target = 8 â†’ sorted = [1, 3, 5]

Start with left = 0, right = 2  
sum = 1 + 5 = 6 < 8 â†’ all pairs between 1 and 5 are valid â†’ add (2 - 0) = 2, move left to 1  
Now left = 1, right = 2 â†’ sum = 3 + 5 = 8 â†’ not valid â†’ move right to 1 â†’ loop ends

Total = 2 pairs

ğŸ”§ Code:
*/
class Solution {
    int countPairs(int arr[], int target) {
        int n = arr.length;
        int cnt = 0;

        // Sort the array to use two-pointer technique
        Arrays.sort(arr);

        int left = 0;
        int right = n - 1;

        // Iterate while left pointer is before right pointer
        while (left < right) {
            int sum = arr[left] + arr[right];

            if (sum < target) {
                /*
                Since arr[left] + arr[right] < target, and the array is sorted,
                all values from arr[left+1] to arr[right] will also form valid pairs with arr[left].
                So we can count all (right - left) pairs in one go.
                */
                cnt += (right - left);
                left++; // Try next left element
            } else {
                // Sum is too big â†’ move right to reduce sum
                right--;
            }
        }

        return cnt; // Return the total valid pairs found
    }
}
