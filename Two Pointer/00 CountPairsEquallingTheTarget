/*
=====================================================================
🧠 Problem: Count Pairs with Given Sum (Two Sum with duplicates)
🔗 GFG Link: https://www.geeksforgeeks.org/problems/count-pairs-with-given-sum5022/1

📌 Problem Statement:
You're given a sorted array (with possible duplicates) and a target sum.
You need to count the number of unique pairs (i, j) such that:
  - i < j
  - arr[i] + arr[j] == target

💡 Example:
Input: arr[] = {1, 1, 2, 2, 3, 3, 4}, target = 4
Output: 4
Explanation:
Valid pairs are:
(1, 3), (1, 3), (2, 2), (1, 3) — total 4 pairs.
=====================================================================
*/

/* --------------------------------------------
🔸 Brute-Force Approach: Check all pairs
🔸 Time Complexity: O(N^2)
🔸 Space Complexity: O(1)
-------------------------------------------- */

/*
💭 Explanation:
Loop through every possible pair (i, j) with i < j.
For each pair, if arr[i] + arr[j] == target, increment the count.
This checks every possible pair without using any extra data structures.
*/

class BruteForceSolution {

    int countPairs(int[] arr, int target) {
        int count = 0;

        // Traverse each pair only once
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] + arr[j] == target) {
                    count++;
                }
            }
        }
        return count;
    }
}

/* --------------------------------------------
🔹 Optimized Approach: Two Pointer with Duplicates
🔹 Time Complexity: O(N)
🔹 Space Complexity: O(1)
-------------------------------------------- */

/*
💭 Explanation:
- Since the array is sorted, use two pointers: one at the start (l), one at the end (r).
- Move them based on the sum:
   🔹 If arr[l] + arr[r] < target → move l forward (increase sum)
   🔹 If arr[l] + arr[r] > target → move r backward (decrease sum)
   🔹 If sum == target:
       - Count how many times arr[l] repeats (c1), and how many times arr[r] repeats (c2).
       - If arr[l] == arr[r], then we're picking the same number twice (like [2,2,2] for target 4)
         → number of pairs = (c1 * (c1 - 1)) / 2
       - Else → total pairs = c1 * c2
       - Move both pointers accordingly
*/

/*
🧪 Dry Run:
Input: arr[] = {1, 1, 2, 2, 3, 3, 4}, target = 4
Steps:
l = 0, r = 6 → arr[0] + arr[6] = 1 + 4 = 5 > 4 → r--
l = 0, r = 5 → 1 + 3 = 4 ✔️ → count c1=2 (1s), c2=2 (3s) → add 2*2 = 4 → l=2, r=3
l = 2, r = 3 → 2 + 2 = 4 ✔️ → c1=2, c2=0 → add 1 pair (2C2 = 1) → done
*/

class Solution {

    int countPairs(int arr[], int target) {
        int l = 0, r = arr.length - 1;
        int cnt = 0;

        while (l < r) {
            int sum = arr[l] + arr[r];

            if (sum > target) {
                // If sum is too big, move right pointer left
                r--;
            } else if (sum < target) {
                // If sum is too small, move left pointer right
                l++;
            } else {
                // sum == target → count how many times arr[l] and arr[r] repeat
                int c1 = 0, c2 = 0;
                int ele1 = arr[l], ele2 = arr[r];

                // Count duplicates from the left
                while (l <= r && arr[l] == ele1) {
                    l++;
                    c1++;
                }

                // Count duplicates from the right
                while (l <= r && arr[r] == ele2) {
                    r--;
                    c2++;
                }

                if (ele1 == ele2) {
                    /*
                    When both elements are the same (like 2,2), we choose 2 from c1 duplicates
                    → Use combination formula (c1 * (c1 - 1)) / 2
                    */
                    cnt += (c1 * (c1 - 1)) / 2;
                } else {
                    // Otherwise, multiply occurrences
                    cnt += c1 * c2;
                }
            }
        }

        return cnt;
    }
}
