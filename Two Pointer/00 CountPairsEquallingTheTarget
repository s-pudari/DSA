/*
=====================================================================
ğŸ§  Problem: Count Pairs with Given Sum (Two Sum with duplicates)
ğŸ”— GFG Link: https://www.geeksforgeeks.org/problems/count-pairs-with-given-sum5022/1

/*
ğŸ”¥ PROBLEM: Find All Pairs With Sum = 0 ğŸ”¥
-------------------------------------------
(Variation of the 2-Sum / Two-Pointer pattern)

Given an integer array `arr`, return all **unique pairs**
[arr[i], arr[j]] such that:

        arr[i] + arr[j] = 0  
        i < j  
        No duplicate pairs allowed  

Example:
arr = [3, -3, 1, -1, 2]  
Pairs = [-3,3], [-1,1]

---

ğŸ” BRUTE-FORCE APPROACH
------------------------
ğŸ’¡ Idea:
- For every index i, pair it with j > i.
- Check if arr[i] + arr[j] == 0.
- Add the pair if valid.
- Use a set or sorting inside the loop to prevent duplicates.

ğŸ•’ Time Complexity: O(nÂ²)  
ğŸ§  Space Complexity: O(1) or O(n) depending on duplicate handling

ğŸ” Dry Run (arr = [1, -1, 2, -2]):
(i=0,j=1) â†’ 1 + (-1) = 0 â†’ add  
(i=2,j=3) â†’ 2 + (-2) = 0 â†’ add  

Brute-force Code:
------- */
public static ArrayList<ArrayList<Integer>> getPairsBrute(int[] arr) {
    ArrayList<ArrayList<Integer>> ans = new ArrayList<>();

    for (int i = 0; i < arr.length; i++) {
        for (int j = i + 1; j < arr.length; j++) {

            if (arr[i] + arr[j] == 0) {
                ArrayList<Integer> li = new ArrayList<>();
                li.add(arr[i]);
                li.add(arr[j]);

                ans.add(li);
            }
        }
    }

    return ans;
}

----------------------------------------------

âœ… OPTIMIZED APPROACH: Sorting + Two Pointers
----------------------------------------------
ğŸ’¡ Idea:
- Sort the array.
- Use pointers `i` (left) and `j` (right).
- If arr[i] + arr[j] < 0 â†’ move i++  
- If arr[i] + arr[j] > 0 â†’ move j--  
- If equal to 0 â†’ record pair  
- Skip duplicates to avoid repeating the same pair.

ğŸ•’ Time Complexity: O(n log n)  
ğŸ§  Space Complexity: O(1) (ignoring answer list)

ğŸ” Dry Run (arr = [2, -2, 1, -1]):
Sorted = [-2, -1, 1, 2]  
i=0,j=3 â†’ -2+2 = 0 â†’ add  
i=1,j=2 â†’ -1+1 = 0 â†’ add  
i=2,j=1 â†’ stop  

Code (Optimized):
-------
*/

class Solution {
    public static ArrayList<ArrayList<Integer>> getPairs(int[] arr) {

        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        Arrays.sort(arr);                    // sort array for two-pointer
        int n = arr.length;
        int i = 0, j = n - 1;

        while (i < j) {

            int sum = arr[i] + arr[j];

            if (sum < 0) {                   // need bigger number
                i++;
            }
            else if (sum > 0) {              // need smaller number
                j--;
            }
            else {                            // found a valid pair
                ArrayList<Integer> li = new ArrayList<>();
                li.add(arr[i]);
                li.add(arr[j]);

                ans.add(li);

                i++;
                j--;

                // skip duplicates on left
                while (i < n && arr[i] == arr[i - 1]) {
                    i++;
                }

                // skip duplicates on right
                while (j >= 0 && arr[j] == arr[j + 1]) {
                    j--;
                }
            }
        }

        return ans;
    }
}
