//https://www.geeksforgeeks.org/batch/gfg-160-problems/track/two-pointer-technique-gfg-160/problem/count-possible-triangles-1587115620
/*
ðŸŽ¯ Problem: Count Possible Triangles

Given an integer array `arr[]` representing lengths of rods, 
return the number of triplets (i, j, k) that **can form a triangle**.

ðŸ”º Triangle Rule:
For any 3 sides a, b, c to form a triangle:  
    âž¤ sum of any two sides must be greater than the third.
    âž¤ a + b > c, b + c > a, a + c > b

ðŸ“Œ Since the array only contains positive values, 
we can **sort it** and just check:
    âž¤ if arr[k] < arr[i] + arr[j]

---

ðŸ§  Brute-Force Approach:

ðŸ”¸ Idea:
- Use 3 nested loops to pick all triplets (i < j < k)
- Check if arr[i] + arr[j] > arr[k] and similar conditions
- Count such valid combinations

ðŸ“ˆ Time Complexity: O(nÂ³)  
ðŸ“¦ Space Complexity: O(1)

ðŸ§ª Dry Run:
arr = [4, 6, 3, 7]
â†’ After sorting: [3, 4, 6, 7]
Valid triangles:
(3,4,6), (3,6,7), (4,6,7), (3,4,7) â†’ count = 4

ðŸ”§ Code:
*/
// Uncomment to test brute-force

class Solution {
    static int countTriangles(int arr[]) {
        int n = arr.length;
        int count = 0;

        // Check every triplet
        for (int i = 0; i < n - 2; i++) {
            for (int j = i + 1; j < n - 1; j++) {
                for (int k = j + 1; k < n; k++) {
                    // Triangle condition
                    if (arr[i] + arr[j] > arr[k] &&
                        arr[j] + arr[k] > arr[i] &&
                        arr[k] + arr[i] > arr[j]) {
                        count++;
                    }
                }
            }
        }

        return count;
    }
}


/*
-----------------------------------------------------------------------------------------
ðŸ§  Optimized Approach (Two Pointer + Sorting)

ðŸ”¸ Idea:
- First sort the array in ascending order.
- Fix the largest side (say at index i), and use two pointers to find valid smaller sides.
- Since the array is sorted:
    âž¤ If arr[l] + arr[r] > arr[i], then all values from l to râˆ’1 also satisfy the triangle condition.

ðŸ“ˆ Time Complexity: O(nÂ²)  
ðŸ“¦ Space Complexity: O(1)

ðŸ§ª Dry Run:
arr = [4, 6, 3, 7] â†’ sorted â†’ [3, 4, 6, 7]

i = 2 (value 6) â†’ l=0, r=1 â†’ 3+4 > 6 â†’ valid â†’ count++
i = 3 (value 7) â†’ combinations: (3,4), (3,6), (4,6) â†’ all valid â†’ count += 3

ðŸ”§ Code:
*/

class Solution {
    // Function to count the number of possible triangles.
    static int countTriangles(int arr[]) {
        int cnt = 0;

        // Step 1: Sort the array to enable two-pointer logic
        Arrays.sort(arr);

        // Step 2: Fix the largest side at index i and find two smaller sides
        for (int i = arr.length - 1; i >= 2; i--) {
            int l = 0, r = i - 1; // Two pointers start from beginning and just before i

            while (l < r) {
                /*
                  Triangle condition:
                  If arr[l] + arr[r] > arr[i], then
                  all elements from index l to r-1 will also satisfy the condition with r
                  because arr is sorted and smaller values appear before
                */
                if (arr[l] + arr[r] > arr[i]) {
                    cnt += (r - l); // count all such pairs with this r
                    r--; // try next smaller value
                } else {
                    /*
                      If sum is not greater, we need a larger left side,
                      so we move l forward
                    */
                    l++;
                }
            }
        }

        return cnt;
    }
}
