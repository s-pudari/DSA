/*
ğŸ¯ Problem: Longest Harmonious Subsequence (LHS)

You are given an integer array `nums`. A harmonious subsequence is one where the 
**difference between the maximum and minimum element is exactly 1**.

Your task is to find the **length** of the **longest** harmonious subsequence 
that can be formed from the input array.

ğŸ“Œ Note:
- You can only **select elements, not rearrange them** (subsequence, not substring).
- You are NOT required to return the actual subsequence, just its length.

-----------------------------------------------------
âœ… Optimized Approach (Using HashMap):
-----------------------------------------------------
ğŸ§  Idea:
- Count frequencies of all elements.
- For each element `num`, check if `num+1` exists in the map.
- If yes, their combined frequency = valid LHS.

ğŸ” Dry Run:
Input: nums = [1, 3, 2, 2, 5, 2, 3, 7]

Step 1: Frequency map:
{
  1:1, 2:3, 3:2, 5:1, 7:1
}

Step 2: Check for each key:
- key = 1 â has 2 â count = 1+3 = 4
- key = 2 â has 3 â count = 3+2 = 5  âœ… max
- key = 3 â has 4 âŒ skip
- ...

ğŸ” Final Answer: 5

ğŸ•’ Time Complexity: O(N)
ğŸ§  Space Complexity: O(N)

*/

class Solution {
    public int findLHS(int[] nums) {
        int res = 0;

        // Step 1: Frequency map to count each number's occurrences
        HashMap<Integer, Integer> hm = new HashMap<>();
        for (int num : nums) {
            hm.put(num, hm.getOrDefault(num, 0) + 1);
        }

        // Step 2: Iterate over each key and check if (key + 1) exists
        for (int num : nums) {
            int min = num;
            int max = num + 1;

            // Only consider pairs where difference is exactly 1
            if (hm.containsKey(max)) {
                // Update the result with maximum frequency sum
                res = Math.max(res, hm.get(min) + hm.get(max));
            }
        }

        return res;
    }

    /*
    -----------------------------------------------------
    ğŸŒ Brute Force Approach (Sorting + Sliding Window):
    -----------------------------------------------------
    ğŸ§  Idea:
    - Sort the array.
    - Use two pointers (i and j) to find windows where max - min = 1.

    ğŸ” Dry Run:
    Sorted nums = [1, 2, 2, 2, 3, 3, 5, 7]

    - i = 4, j = 0 â nums[4] - nums[0] = 3 - 1 = 2 âŒ
    - j moves forward to make window valid.
    - When nums[i] - nums[j] == 1 â update length.

    ğŸ•’ Time Complexity: O(N log N)
    ğŸ§  Space Complexity: O(1)

    Code:
    ------------------
    public int findLHS(int[] nums) {
        Arrays.sort(nums);  // Sorting step

        int maxlength = 0;
        int j = 0;

        for (int i = 0; i < nums.length; i++) {
            // If window is invalid (diff > 1), shrink it
            while (nums[i] - nums[j] > 1) {
                ++j;  // Move j forward to try to reduce the difference
            }

            // Valid window (diff == 1)
            if (nums[i] - nums[j] == 1) {
                maxlength = Math.max(maxlength, i - j + 1);
            }
        }

        return maxlength;
    }
    */
}
