/*
LeetCode 61 â€” Rotate List
Link: https://leetcode.com/problems/rotate-list/

-----------------------------------------------------------
ðŸ” PROBLEM EXPLANATION (BEGINNER-FRIENDLY)
-----------------------------------------------------------
You are given a linked list and an integer k.  
You must rotate the list to the right by k positions.

Example:
List: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5,  k = 2  
After rotation: 4 â†’ 5 â†’ 1 â†’ 2 â†’ 3

Rotation means:
- Last k nodes move to the front
- Order must remain the same

-----------------------------------------------------------
APPROACH (Optimized)
-----------------------------------------------------------
Time Complexity: O(n)
Space Complexity: O(1)

ðŸ§  IDEA:
1. Find length of list.
2. Make the list circular by connecting tail â†’ head.
3. Effective rotations = k % length
4. Move (length â€“ k) steps to find new tail.
5. New head = newTail.next
6. Break the cycle by setting newTail.next = null

-----------------------------------------------------------
DRY RUN
-----------------------------------------------------------
List: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5, k = 2  
Length = 5  
Make circular: 1â†’2â†’3â†’4â†’5â†’(back to 1)

k % 5 = 2  
Steps to new tail = 5 â€“ 2 = 3

Move 3 steps â†’ new tail = node 3  
New head = node 4  
Break link â†’ result: 4 â†’ 5 â†’ 1 â†’ 2 â†’ 3
*/

class Solution {
    public ListNode rotateRight(ListNode head, int k) {

        /* Edge cases: empty list, single node, or zero rotation */
        if (head == null || head.next == null || k == 0) 
            return head;

        /* Step 1: Find length and last node (tail) */
        ListNode temp = head;
        int len = 1;

        while (temp.next != null) {
            len++;
            temp = temp.next;
        }

        /* Step 2: Make the list circular by connecting tail â†’ head */
        temp.next = head;

        /* Step 3: Compute effective rotations */
        k = k % len;
        int stepsToNewTail = len - k;

        /* Step 4: Move to the new tail */
        temp = head;
        while (stepsToNewTail-- > 1) {
            temp = temp.next;
        }

        /* Step 5 & 6: Set new head and break the circle */
        head = temp.next;
        temp.next = null;

        /* Final rotated list head */
        return head;
    }
}
