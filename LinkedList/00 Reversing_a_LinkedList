/*
Problem: Reverse a Linked List
Link: https://leetcode.com/problems/reverse-linked-list/

We are given the head of a singly linked list. 
The task is to reverse the list and return the new head.

------------------------------------------------------------
BRUTE FORCE (Using Stack Idea - for understanding only)
------------------------------------------------------------
1. Push all nodes into a stack.
2. Pop nodes one by one and reconnect them in reverse order.
3. Return the new head.

- Time Complexity: O(N) (we traverse list twice)
- Space Complexity: O(N) (stack stores all nodes)

Not implemented below since iterative is more optimal.
------------------------------------------------------------
OPTIMIZED APPROACH 1: Iterative (In-place Reversal)
------------------------------------------------------------
1. Maintain three pointers → prev, curr, next.
2. Traverse the list and reverse links as we go.
3. Finally, prev will point to the new head.

- Time Complexity: O(N)
- Space Complexity: O(1)

Dry Run Example:
Input: 1 -> 3 -> 2 -> 4
Step 1: prev=null, curr=1
Step 2: Reverse 1 -> null, prev=1, curr=3
Step 3: Reverse 3 -> 1, prev=3, curr=2
Step 4: Reverse 2 -> 3, prev=2, curr=4
Step 5: Reverse 4 -> 2, prev=4, curr=null
Output: 4 -> 2 -> 3 -> 1
------------------------------------------------------------
OPTIMIZED APPROACH 2: Recursion
------------------------------------------------------------
1. Base Case → If head is null or single node, return head.
2. Recursively reverse remaining list.
3. Adjust pointers to reverse current node.

- Time Complexity: O(N)
- Space Complexity: O(N) (recursive call stack)

Dry Run Example:
Input: 1 -> 3 -> 2 -> 4
Call reverse(1)
   → reverse(3)
       → reverse(2)
           → reverse(4) → returns 4
Backtracking:
4->2, 2->3, 3->1
Output: 4 -> 2 -> 3 -> 1
*/

// ------------------ Iterative Solution ------------------
class SolutionIterative {
    Node reverseList(Node head) {
        Node curr = head;  // current pointer
        Node prev = null;  // previous pointer
        
        // Traverse and reverse links
        while (curr != null) {
            Node next = curr.next; // save next node
            curr.next = prev;      // reverse link
            prev = curr;           // move prev forward
            curr = next;           // move curr forward
        }
        
        // prev now points to new head
        return prev;
    }
}

// ------------------ Recursive Solution ------------------
class SolutionRecursive {
    public Node reverseList(Node head) {
        // Base case: empty list or single node
        if (head == null || head.next == null) {
            return head;
        }

        // Recursively reverse the rest
        Node newHead = reverseList(head.next);

        // Adjust current node's link
        Node front = head.next; 
        front.next = head;
        head.next = null;

        return newHead;
    }
}

// ------------------ Node Class & Driver ------------------
class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class Main {
    public static void printLinkedList(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Original list: 1 -> 3 -> 2 -> 4
        Node head = new Node(1);
        head.next = new Node(3);
        head.next.next = new Node(2);
        head.next.next.next = new Node(4);

        System.out.print("Original: ");
        printLinkedList(head);

        // Iterative reverse
        SolutionIterative sol1 = new SolutionIterative();
        head = sol1.reverseList(head);
        System.out.print("Reversed (Iterative): ");
        printLinkedList(head);

        // Reverse back using recursion
        SolutionRecursive sol2 = new SolutionRecursive();
        head = sol2.reverseList(head);
        System.out.print("Reversed (Recursive): ");
        printLinkedList(head);
    }
}
