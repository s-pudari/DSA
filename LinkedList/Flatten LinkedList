/*
Problem: Flattening a Linked List
Link: https://www.geeksforgeeks.org/problems/flattening-a-linked-list/1

We are given a special linked list where each node has two pointers:
1. `next` → points to the next linked list
2. `bottom` → points to the linked list at that level

Task: Flatten the list so that all nodes appear in a single list sorted in ascending order, 
using only the `bottom` pointer.

------------------------------------------------------------
BRUTE FORCE APPROACH:
------------------------------------------------------------
1. Traverse the main linked list.
2. For each sub-list (connected using bottom), collect all values in an ArrayList.
3. Sort the ArrayList.
4. Construct a new flattened linked list from the sorted values.
- Time Complexity: O(N log N) → due to sorting
- Space Complexity: O(N) → ArrayList to store all nodes

Dry Run Example:
Input:
5 -> 10 -> 19 -> 28
|    |     |     |
7    20    22    35
|          |     |
8          50    40
|                |
30               45

Step 1: Collect → [5,7,8,30,10,20,19,22,50,28,35,40,45]
Step 2: Sort → [5,7,8,10,19,20,22,28,30,35,40,45,50]
Step 3: Build new linked list (bottom connected)
Output: 5->7->8->10->19->20->22->28->30->35->40->45->50
*/

class SolutionBrute {
    public Node flatten(Node root) {
        ArrayList<Integer> arr = new ArrayList<>();

        Node temp = root;
        // Traverse horizontally
        while (temp != null) {
            Node temp1 = temp;
            // Traverse vertically
            while (temp1 != null) {
                arr.add(temp1.data);
                temp1 = temp1.bottom;
            }
            temp = temp.next;
        }

        // Sort all collected values
        Collections.sort(arr);

        // Build new linked list using bottom pointers
        return buildFlattenedList(arr);
    }

    private Node buildFlattenedList(ArrayList<Integer> arr) {
        Node temp = new Node(-1); // dummy node
        Node dummy = temp;

        for (int i = 0; i < arr.size(); i++) {
            dummy.bottom = new Node(arr.get(i));
            dummy = dummy.bottom;
        }
        return temp.bottom;
    }
}

/*
------------------------------------------------------------
OPTIMIZED APPROACH (Merge like Merge Sort):
------------------------------------------------------------
1. Recursively flatten the right side (root.next).
2. Merge current vertical list (root) with flattened next list.
3. Return the merged sorted list.

- Time Complexity: O(N) → Each node is visited once
- Space Complexity: O(1) → In-place merging, recursion stack O(height)

Dry Run Example:
Input: Same as above
Step 1: Flatten(10) → merges into sorted list starting from 10
Step 2: Flatten(19) → merges into sorted list starting from 19
Step 3: Flatten(28) → merges into sorted list starting from 28
Step 4: Merge root (5) with result → final sorted flattened list
Output: 5->7->8->10->19->20->22->28->30->35->40->45->50
*/

class SolutionOptimized {
    // Function to flatten a linked list
    Node flatten(Node root) {
        if (root == null || root.next == null) return root;

        // Recursively flatten the next list
        root.next = flatten(root.next);

        // Merge current list with next flattened list
        root = mergeTwoLists(root, root.next);

        return root;
    }

    // Merge two bottom-linked sorted lists
    Node mergeTwoLists(Node a, Node b) {
        Node temp = new Node(0); // dummy node
        Node res = temp;

        while (a != null && b != null) {
            if (a.data < b.data) {
                temp.bottom = a;
                a = a.bottom;
            } else {
                temp.bottom = b;
                b = b.bottom;
            }
            temp = temp.bottom;
        }

        // Attach remaining nodes
        if (a != null) temp.bottom = a;
        else temp.bottom = b;

        return res.bottom;
    }
}
