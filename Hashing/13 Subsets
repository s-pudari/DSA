/*
-------------------------------------------------------------
ğŸ§© Problem: Count the Number of Consecutive Number Subsets
ğŸ“Œ Simplified Variation of: "Longest Consecutive Sequence" + "Group Splitting"

ğŸ¯ Problem Statement:
You're given an array `arr[]` of integers.
Split the array into the **minimum number of subsets** such that:
- Each subset contains only **consecutive numbers** (e.g., [1,2,3])
- No element is repeated across subsets
- Return the **number of such subsets** needed.

-------------------------------------------------------------
ğŸ” Example:

Input: arr = [3, 1, 2, 5, 6]  
â†’ Consecutive subsets: [1,2,3], [5,6]  
â†’ Output: 2

Input: arr = [1, 4, 7]  
â†’ No consecutive pairs â†’ each number forms its own subset  
â†’ Output: 3

-------------------------------------------------------------
*/

import java.util.*;

class Solution {

    /*-----------------------------------------------------
      âœ… Approach 1: Sort + Check Gaps
      ğŸ•’ Time Complexity: O(n log n)  (due to sorting)
      ğŸ§  Space Complexity: O(1)  (in-place)

      ğŸ§¾ Logic:
      - Sort the array.
      - Traverse and count how many **gaps** exist where `arr[i]+1 != arr[i+1]`.
      - Each gap means we start a new subset.
      - Initialize `cnt = 1` because we always have at least one subset.

      -----------------------------------------------------*/

    public int numOfSubsetSorted(int[] arr) {
        int count = 1;  // Start with one subset by default
        Arrays.sort(arr);

        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i] + 1 != arr[i + 1]) {
                count++;
            }
        }

        return count;
    }

    /*
    ğŸ”„ Dry Run:
    Input: arr = [3, 1, 2, 5, 6] â†’ sorted = [1, 2, 3, 5, 6]
    â†’ 1+1=2 âœ…, 2+1=3 âœ…, 3+1=4 âŒ â†’ gap â†’ count++
    â†’ 5+1=6 âœ…
    â†’ Final count = 2
    -----------------------------------------------------*/


    /*-----------------------------------------------------
      âœ… Approach 2: HashSet + Start-of-Sequence Detection
      ğŸ•’ Time Complexity: O(n)
      ğŸ§  Space Complexity: O(n)

      ğŸ§¾ Logic:
      - Store all elements in a HashSet (for O(1) lookups).
      - Traverse through the HashSet.
      - For each number, check if it is the **start of a sequence**: i.e., if (num-1) is not in set.
      - If so, start a new subset (increase count).
      - We only count distinct starting points of sequences.

      ğŸ”¥ Advantage: No need to sort â€” faster on large inputs.

      -----------------------------------------------------*/

    public int numOfSubset(int[] arr) {
        int count = 0;
        HashSet<Integer> set = new HashSet<>();

        // Step 1: Add all elements to set
        for (int num : arr) {
            set.add(num);
        }

        // Step 2: Count starts of consecutive sequences
        for (int num : set) {
            if (!set.contains(num - 1)) {
                // This is the start of a new subset
                count++;
            }
        }

        return count;
    }

    /*
    ğŸ”„ Dry Run:
    arr = [3, 1, 2, 5, 6] â†’ set = {1,2,3,5,6}

    Check:
    1 â†’ no 0 â†’ âœ… count++
    2 â†’ has 1 â†’ âŒ
    3 â†’ has 2 â†’ âŒ
    5 â†’ no 4 â†’ âœ… count++
    6 â†’ has 5 â†’ âŒ

    Final count = 2
    -----------------------------------------------------*/
}
