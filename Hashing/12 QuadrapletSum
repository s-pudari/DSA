/*
-------------------------------------------------------
🧩 Problem: Count Quadruplets with Sum Equal to Target
📌 LeetCode-like Variation (Custom problem)

🎯 Problem Explanation:
You are given an array of integers `arr[]` and a target sum `target`.

Your task is to count the **number of unique quadruplets (i, j, k, l)** such that:
- i < j < k < l (i.e., all indices are different and in order)
- arr[i] + arr[j] + arr[k] + arr[l] == target

🧠 Note: We only need to count valid combinations. Duplicates in values are allowed,
but quadruplet positions must be unique and ordered.

-------------------------------------------------------
🔍 Example:

Input: arr = [1, 2, 3, 4, 5], target = 10  
→ Valid quadruplets: (0,1,2,3) → 1+2+3+4=10  
→ Total = 1

-------------------------------------------------------
*/

import java.util.*;

class Solution {

    /*-----------------------------------------------------
      ✅ Brute Force Approach (4 nested loops)
      🕒 Time Complexity: O(n⁴)
      🧠 Space Complexity: O(1)

      🧾 Explanation:
      - Try every possible combination of 4 distinct indices (i, j, k, l).
      - Check if their sum equals the target.
      - If yes, increase the count.

      Works fine for small inputs (n <= 50), but very slow for large arrays.
      -----------------------------------------------------*/

    public int countSumBruteForce(int[] arr, int target) {
        int n = arr.length;
        int count = 0;

        // Loop over all combinations of 4 distinct and ordered indices
        for (int i = 0; i < n - 3; i++) {
            for (int j = i + 1; j < n - 2; j++) {
                for (int k = j + 1; k < n - 1; k++) {
                    for (int l = k + 1; l < n; l++) {
                        // Check if sum of quadruplet equals the target
                        if (arr[i] + arr[j] + arr[k] + arr[l] == target) {
                            count++;
                        }
                    }
                }
            }
        }

        return count;
    }

    /*
    🔄 Dry Run for Brute Force:
    Input: arr = [1, 2, 3, 4, 5], target = 10

    i=0, j=1, k=2, l=3 → 1+2+3+4 = 10 ✅ → count=1  
    All other combinations don't match target

    Final count = 1
    -----------------------------------------------------*/


    /*-----------------------------------------------------
      ✅ Optimized Approach using HashMap (2-sum + 2-sum)
      🕒 Time Complexity: O(n²)
      🧠 Space Complexity: O(n²)

      🧾 Explanation:
      - Think of the problem as: find two pairs (a+b) and (c+d) such that their sum equals `target`.
      - Use a HashMap to store all 2-sums that occur **before the current index**.
      - For every new pair (i,j), we check if (target - (arr[i] + arr[j])) exists in the map.

      💡 Key Idea:
      - The map keeps track of all (arr[p] + arr[q]) pairs with p < q < i
      - This ensures that i < j always, and avoids duplicates

      -----------------------------------------------------*/

    public int countSum(int[] arr, int target) {
        int n = arr.length;
        int count = 0;

        // HashMap to store all previous pair sums
        HashMap<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < n - 1; i++) {
            /* Phase 1: Check future pairs (i, j) and search for matching complements */
            for (int j = i + 1; j < n; j++) {
                int currentSum = arr[i] + arr[j];
                int complement = target - currentSum;

                // Add the number of previous pairs that sum to the complement
                count += map.getOrDefault(complement, 0);
            }

            /* Phase 2: Store all pairs (arr[k] + arr[i]) where k < i in map */
            for (int k = 0; k < i; k++) {
                int pastSum = arr[i] + arr[k];
                map.put(pastSum, map.getOrDefault(pastSum, 0) + 1);
            }
        }

        return count;
    }

    /*
    🔄 Dry Run for Optimized:
    Input: arr = [1, 2, 3, 4, 5], target = 10

    Step-by-step:
    i=0 → map={} → nothing to add

    i=1:
      j=2: 2+3=5, complement=5 → not in map
      j=3: 2+4=6, complement=4 → not in map
      j=4: 2+5=7, complement=3 → not in map
      map: (1+2)=3

    i=2:
      j=3: 3+4=7, complement=3 → map[3]=1 → count=1
      j=4: 3+5=8, complement=2 → not in map
      map: (1+3)=4, (2+3)=5

    Final count = 1
    -----------------------------------------------------*/
}
