/*
-------------------------------------------------------
ğŸ§© Problem: Count Quadruplets with Sum Equal to Target
ğŸ“Œ LeetCode-like Variation (Custom problem)

ğŸ¯ Problem Explanation:
You are given an array of integers `arr[]` and a target sum `target`.

Your task is to count the **number of unique quadruplets (i, j, k, l)** such that:
- i < j < k < l (i.e., all indices are different and in order)
- arr[i] + arr[j] + arr[k] + arr[l] == target

ğŸ§  Note: We only need to count valid combinations. Duplicates in values are allowed,
but quadruplet positions must be unique and ordered.

-------------------------------------------------------
ğŸ” Example:

Input: arr = [1, 2, 3, 4, 5], target = 10  
â†’ Valid quadruplets: (0,1,2,3) â†’ 1+2+3+4=10  
â†’ Total = 1

-------------------------------------------------------
*/

import java.util.*;

class Solution {

    /*-----------------------------------------------------
      âœ… Brute Force Approach (4 nested loops)
      ğŸ•’ Time Complexity: O(nâ´)
      ğŸ§  Space Complexity: O(1)

      ğŸ§¾ Explanation:
      - Try every possible combination of 4 distinct indices (i, j, k, l).
      - Check if their sum equals the target.
      - If yes, increase the count.

      Works fine for small inputs (n <= 50), but very slow for large arrays.
      -----------------------------------------------------*/

    public int countSumBruteForce(int[] arr, int target) {
        int n = arr.length;
        int count = 0;

        // Loop over all combinations of 4 distinct and ordered indices
        for (int i = 0; i < n - 3; i++) {
            for (int j = i + 1; j < n - 2; j++) {
                for (int k = j + 1; k < n - 1; k++) {
                    for (int l = k + 1; l < n; l++) {
                        // Check if sum of quadruplet equals the target
                        if (arr[i] + arr[j] + arr[k] + arr[l] == target) {
                            count++;
                        }
                    }
                }
            }
        }

        return count;
    }

    /*
    ğŸ”„ Dry Run for Brute Force:
    Input: arr = [1, 2, 3, 4, 5], target = 10

    i=0, j=1, k=2, l=3 â†’ 1+2+3+4 = 10 âœ… â†’ count=1  
    All other combinations don't match target

    Final count = 1
    -----------------------------------------------------*/


    /*-----------------------------------------------------
      âœ… Optimized Approach using HashMap (2-sum + 2-sum)
      ğŸ•’ Time Complexity: O(nÂ²)
      ğŸ§  Space Complexity: O(nÂ²)

      ğŸ§¾ Explanation:
      - Think of the problem as: find two pairs (a+b) and (c+d) such that their sum equals `target`.
      - Use a HashMap to store all 2-sums that occur **before the current index**.
      - For every new pair (i,j), we check if (target - (arr[i] + arr[j])) exists in the map.

      ğŸ’¡ Key Idea:
      - The map keeps track of all (arr[p] + arr[q]) pairs with p < q < i
      - This ensures that i < j always, and avoids duplicates

      -----------------------------------------------------*/

    public int countSum(int[] arr, int target) {
        int n = arr.length;
        int count = 0;

        // HashMap to store all previous pair sums
        HashMap<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < n - 1; i++) {
            /* Phase 1: Check future pairs (i, j) and search for matching complements */
            for (int j = i + 1; j < n; j++) {
                int currentSum = arr[i] + arr[j];
                int complement = target - currentSum;

                // Add the number of previous pairs that sum to the complement
                count += map.getOrDefault(complement, 0);
            }

            /* Phase 2: Store all pairs (arr[k] + arr[i]) where k < i in map */
            for (int k = 0; k < i; k++) {
                int pastSum = arr[i] + arr[k];
                map.put(pastSum, map.getOrDefault(pastSum, 0) + 1);
            }
        }

        return count;
    }

    /*
    ğŸ”„ Dry Run for Optimized:
    Input: arr = [1, 2, 3, 4, 5], target = 10

    Step-by-step:
    i=0 â†’ map={} â†’ nothing to add

    i=1:
      j=2: 2+3=5, complement=5 â†’ not in map
      j=3: 2+4=6, complement=4 â†’ not in map
      j=4: 2+5=7, complement=3 â†’ not in map
      map: (1+2)=3

    i=2:
      j=3: 3+4=7, complement=3 â†’ map[3]=1 â†’ count=1
      j=4: 3+5=8, complement=2 â†’ not in map
      map: (1+3)=4, (2+3)=5

    Final count = 1
    -----------------------------------------------------*/
}
