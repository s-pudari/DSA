/*
-------------------------------------------------------------
ðŸ§© Problem: Group Shifted Strings
ðŸ“Œ LeetCode Style Problem (Variation)

ðŸŽ¯ Problem Statement:
Given an array of strings, group all strings that belong to the **same shifting sequence**.

ðŸ“Œ Definition:
A "shifting sequence" is a group of strings where each character is shifted by the same amount to get the next string.
For example:
â†’ "abc" â†’ "bcd" â†’ "cde" ... (all differ by +1 shift)
â†’ "az" â†’ "ba" (aâ†’b and zâ†’a both shift by +1)

ðŸ“¥ Input: arr[] = ["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]
ðŸ“¤ Output: [
  ["abc", "bcd", "xyz"],
  ["az", "ba"],
  ["acef"],
  ["a", "z"]
]

-------------------------------------------------------------
ðŸ§  Key Insight:
For each string, generate a **"pattern"** based on the **distance** between its characters.
If two strings share the same pattern, they are in the same group.

For example:
â†’ "abc" â†’ distances: b-a = 1, c-b = 1 â†’ pattern = "1,1,"
â†’ "bcd" â†’ pattern = "1,1," â†’ âœ… same group

-------------------------------------------------------------
*/

import java.util.*;

class Solution {

    /*-----------------------------------------------------
      âœ… Optimized Grouping Approach using HashMap
      ðŸ•’ Time Complexity: O(n * m), where:
         n = number of strings, m = max string length
      ðŸ§  Space Complexity: O(n * m) for HashMap & result

      ðŸ§¾ Logic:
      - For each string, generate a key based on its shifting pattern.
      - Use a HashMap to group all strings with the same pattern.
      - Finally, return all values from the map as grouped result.

      -----------------------------------------------------*/

    public ArrayList<ArrayList<String>> groupShiftedString(String[] arr) {
        ArrayList<ArrayList<String>> result = new ArrayList<>();
        HashMap<String, List<String>> map = new HashMap<>();

        for (String str : arr) {
            StringBuilder pattern = new StringBuilder();

            /* 
            ðŸ§® Generate a unique key representing the distance between characters
            For example, "abc" â†’ (b-a)=1, (c-b)=1 â†’ key = "1,1,"
            */
            for (int i = 1; i < str.length(); i++) {
                char prev = str.charAt(i - 1);
                char curr = str.charAt(i);
                int distance = computeDistance(prev, curr);  // handles wrap-around using modular logic
                pattern.append(distance).append(",");
            }

            String key = pattern.toString();  // pattern becomes the grouping key

            // ðŸ“¦ Add string to the appropriate group in the HashMap
            List<String> group = map.getOrDefault(key, new ArrayList<>());
            group.add(str);
            map.put(key, group);
        }

        // â›³ Convert HashMap values to result list
        for (List<String> group : map.values()) {
            result.add(new ArrayList<>(group));
        }

        return result;
    }

    /*-----------------------------------------------------
      ðŸ” Helper Method: computeDistance
      ðŸ§® Calculates circular distance from prev to curr
      For example:
      - computeDistance('a', 'b') = 1
      - computeDistance('z', 'a') = 1
      - computeDistance('c', 'a') = 24

      This ensures wrap-around handling (circular alphabet)
      -----------------------------------------------------*/

    public int computeDistance(char prev, char curr) {
        int val1 = prev - 'a';
        int val2 = curr - 'a';

        /* 
        If the current letter is ahead (normal case), just subtract.
        If not, wrap around using (26 - val1 + val2)
        */
        return val2 >= val1 ? val2 - val1 : (26 - val1 + val2);
    }

    /*
    ðŸ”„ Dry Run Example:
    Input: ["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]

    Grouping logic:
    - "abc" â†’ "1,1,"
    - "bcd" â†’ "1,1,"         âœ… same as "abc"
    - "xyz" â†’ "1,1,"         âœ… same as above group

    - "az"  â†’ "25,"
    - "ba"  â†’ "25,"          âœ… same as "az"

    - "acef" â†’ "2,2,1,"      â†’ unique

    - "a" â†’ ""               â†’ no shift (single char)
    - "z" â†’ ""               â†’ no shift (single char) âœ… same group as "a"

    Final Output:
    [
      ["abc", "bcd", "xyz"],
      ["acef"],
      ["az", "ba"],
      ["a", "z"]
    ]
    -----------------------------------------------------*/
}
