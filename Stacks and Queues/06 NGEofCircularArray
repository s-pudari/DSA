/*
LeetCode Problem: https://leetcode.com/problems/next-greater-element-i/

Problem Name: Next Greater Element I

------------------------------------------------------------------------------------
Brute Force Approach (Using HashMap)
------------------------------------------------------------------------------------
Explanation:
- For each element in nums1, first find its index in nums2.
- From that index onwards, look to the right until you find the next greater element.
- If found, map it in a HashMap; else map it to -1.
- Finally, build the answer array for nums1 using the HashMap.

Dry Run:
nums1 = [4,1,2], nums2 = [1,3,4,2]

- For 4: found at index=2 in nums2 → right side = [2] → no greater → map[4] = -1
- For 1: found at index=0 → right side = [3,4,2] → next greater = 3 → map[1] = 3
- For 2: found at index=3 → right side = [] → no greater → map[2] = -1

Result = [-1, 3, -1]

Time Complexity: O(n*m)  (n = nums1.length, m = nums2.length)
Space Complexity: O(m)   (for HashMap)
*/

class SolutionBruteForce {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int n = nums2.length;

        // For each element in nums2, find next greater element
        for (int i = 0; i < n; i++) {
            int nextGreater = -1;
            for (int j = i + 1; j < n; j++) {
                if (nums2[j] > nums2[i]) {
                    nextGreater = nums2[j];
                    break;
                }
            }
            map.put(nums2[i], nextGreater);
        }

        // Build answer for nums1 using the map
        int[] ans = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            ans[i] = map.get(nums1[i]);
        }
        return ans;
    }
}

/*
------------------------------------------------------------------------------------
Optimized Approach (Monotonic Stack + HashMap)
------------------------------------------------------------------------------------
Explanation:
- Traverse nums2 from right to left.
- Use a stack to keep track of "next greater" candidates.
- While stack top <= current element, pop it (since it's not greater).
- If stack empty → no next greater, else stack top is the answer.
- Store result in a HashMap.
- Finally, build answer for nums1 using HashMap.

Dry Run:
nums1 = [4,1,2], nums2 = [1,3,4,2]

Traverse nums2 from right → left:
- Start with empty stack
- i=3 (2): stack empty → map[2] = -1 → push(2) → stack=[2]
- i=2 (4): stack=[2], 2 <= 4 pop → empty → map[4]=-1 → push(4) → stack=[4]
- i=1 (3): stack=[4], 4>3 → map[3]=4 → push(3) → stack=[4,3]
- i=0 (1): stack=[4,3], 3>1 → map[1]=3 → push(1) → stack=[4,3,1]

Now build nums1 result:
- map[4] = -1, map[1] = 3, map[2] = -1
Result = [-1,3,-1]

Time Complexity: O(n+m)
Space Complexity: O(m)
*/

class SolutionOptimized {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        HashMap<Integer,Integer> map = new HashMap<>();
        Stack<Integer> st = new Stack<>();

        // Traverse nums2 from right → left
        for (int i = nums2.length - 1; i >= 0; i--) {
            // Remove smaller or equal elements
            while (!st.isEmpty() && st.peek() <= nums2[i]) {
                st.pop();
            }

            // If empty, no next greater; else stack top is next greater
            if (st.isEmpty()) map.put(nums2[i], -1);
            else map.put(nums2[i], st.peek());

            // Push current element
            st.push(nums2[i]);
        }

        // Build result for nums1
        int[] ans = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            ans[i] = map.get(nums1[i]);
        }
        return ans;
    }
}
