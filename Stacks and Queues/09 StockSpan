/*
ðŸ”— Problem Link: https://www.geeksforgeeks.org/problems/stock-span-problem-1587115621/1

ðŸ“Œ Problem Name: Stock Span Problem

ðŸ‘‰ Problem Statement:
Given an array `arr[]` of size `N` representing the price of a stock on each day,
the task is to calculate the stock span for each day.
The stock span of a stockâ€™s price on a given day is the maximum number of consecutive days 
just before the given day, for which the price of the stock is less than or equal to its price on the given day.

---
*/

/* ===========================================================================================
   âœ… Approach 1: Brute Force (Nested Loop)
   -------------------------------------------------------------------------------------------
   - For each element at index `i`, look backwards until you find a greater element or reach start.
   - Count how many consecutive days have price <= current day's price.
   - Store that count in the result array.

   Time Complexity: O(N^2)   // Because for each day, we may traverse back almost N days
   Space Complexity: O(N)    // Result array only
=========================================================================================== */

/*
Example Dry Run:
Input: arr = [100, 80, 60, 70, 60, 75, 85]
Day 0 -> 100: no left elements â†’ span = 1
Day 1 -> 80: only itself â†’ span = 1
Day 2 -> 60: only itself â†’ span = 1
Day 3 -> 70: 70 >= 60 â†’ span = 2
Day 4 -> 60: only itself â†’ span = 1
Day 5 -> 75: 75 >= 60, 75 >= 70 â†’ span = 4
Day 6 -> 85: 85 >= 75, 85 >= 60, 85 >= 70, 85 >= 80 â†’ span = 6
Output: [1, 1, 1, 2, 1, 4, 6]
*/

class Solution {
    public ArrayList<Integer> calculateSpan(int[] arr) {
        int n = arr.length;

        // Result array initialized with default span = 1 for each day
        ArrayList<Integer> ans = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            ans.add(1); // every element has at least a span of 1 (itself)
        }

        // Traverse each day
        for (int i = 1; i < n; i++) {
            // Look backwards until a greater element is found
            for (int j = i - 1; j >= 0 && arr[i] >= arr[j]; j--) {
                ans.set(i, ans.get(i) + 1); // increase span count for day i
            }
        }

        return ans;
    }
}


/* ===========================================================================================
   âœ… Approach 2: Optimized using Stack
   -------------------------------------------------------------------------------------------
   - Maintain a stack that stores indices of elements in decreasing order of price.
   - For each price:
        - Pop all indices where price <= current price (because they are part of span).
        - If stack empty â†’ span = i+1
        - Else â†’ span = i - st.peek()
   - Push current index into stack.

   Time Complexity: O(N)    // Each element pushed/popped at most once
   Space Complexity: O(N)   // Stack + Result array
=========================================================================================== */

/*
Example Dry Run:
Input: arr = [100, 80, 60, 70, 60, 75, 85]
i=0 -> Stack empty â†’ span = 1 â†’ push(0)
i=1 -> Pop none, top=0 â†’ span=1 â†’ push(1)
i=2 -> Pop none, top=1 â†’ span=1 â†’ push(2)
i=3 -> Pop(2 since 70>=60), top=1 â†’ span=2 â†’ push(3)
i=4 -> Pop none, top=3 â†’ span=1 â†’ push(4)
i=5 -> Pop(4,3), top=1 â†’ span=4 â†’ push(5)
i=6 -> Pop(5,1,0) stack empty â†’ span=7 â†’ push(6)
Output: [1, 1, 1, 2, 1, 4, 7] âœ… (Correct spans)
*/

class SolutionOptimized {
    public ArrayList<Integer> calculateSpan(int[] arr) {
        int n = arr.length;

        // Initialize result with zeros
        ArrayList<Integer> ans = new ArrayList<>(Collections.nCopies(n, 0));
        Stack<Integer> st = new Stack<>(); // stack will hold indices

        // Traverse each day
        for (int i = 0; i < n; i++) {
            // Pop smaller or equal prices because they are part of the span
            while (!st.isEmpty() && arr[st.peek()] <= arr[i]) {
                st.pop();
            }

            if (st.isEmpty()) {
                // If stack empty, it means all previous are smaller
                ans.set(i, i + 1);
            } else {
                // Span = difference between current index and index of last greater price
                ans.set(i, i - st.peek());
            }

            // Push current index onto stack
            st.push(i);
        }

        return ans;
    }
}
