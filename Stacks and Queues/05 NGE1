/*
LeetCode Problem: https://leetcode.com/problems/next-greater-element-i/

Problem Name: Next Greater Element I

Explanation:
We are given two arrays nums1 and nums2, where nums1 is a subset of nums2.
For each element in nums1, we need to find the first element to the right of it in nums2 that is greater than it.
If no such element exists, return -1 for that number.

Approach:
1. Use a **monotonic decreasing stack** while traversing nums2 from right to left.
2. Maintain a HashMap to store the next greater element (NGE) for each element of nums2.
   - If stack is empty → NGE = -1
   - Else → NGE = stack.peek()
   - Push current element onto the stack.
3. After preprocessing nums2, build the result for nums1 by fetching values from HashMap.

Time Complexity: O(n + m)  
   (Each element in nums2 is pushed/popped at most once → O(m), and we process nums1 in O(n))  
Space Complexity: O(m)  
   (HashMap + Stack store elements from nums2)

Dry Run Example:
nums1 = [4,1,2]
nums2 = [1,3,4,2]

Traverse nums2 from right to left:
  i=3 → 2 → stack=[] → NGE=-1 → map={2:-1} → stack=[2]
  i=2 → 4 → stack=[2], pop(2) since 4>2 → stack=[] → NGE=-1 → map={2:-1,4:-1} → stack=[4]
  i=1 → 3 → stack=[4], top=4>3 → NGE=4 → map={2:-1,4:-1,3:4} → stack=[4,3]
  i=0 → 1 → stack=[4,3], top=3>1 → NGE=3 → map={2:-1,4:-1,3:4,1:3} → stack=[4,3,1]

Now nums1 lookups:
4 → -1  
1 → 3  
2 → -1  
Final Answer = [-1, 3, -1]
*/

import java.util.*;

class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;

        int[] nge = new int[n]; // Result array for nums1

        Stack<Integer> st = new Stack<>(); // Monotonic decreasing stack
        HashMap<Integer, Integer> hm = new HashMap<>(); // Stores element → NGE

        // Step 1: Preprocess nums2 to find NGE for each element
        for (int i = m - 1; i >= 0; i--) {
            // Maintain decreasing stack
            while (!st.isEmpty() && nums2[i] > st.peek()) {
                st.pop(); // Remove smaller elements (they can't be NGE for current)
            }

            // If stack empty → no NGE exists
            if (st.isEmpty()) {
                hm.put(nums2[i], -1);
            } else {
                // Top of stack is the next greater element
                hm.put(nums2[i], st.peek());
            }

            // Push current element onto stack
            st.push(nums2[i]);
        }

        // Step 2: Build result for nums1 using precomputed HashMap
        for (int i = 0; i < n; i++) {
            nge[i] = hm.get(nums1[i]); // Direct lookup
        }

        return nge;
    }
}
