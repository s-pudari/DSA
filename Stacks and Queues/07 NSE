/*
InterviewBit Problem: https://www.interviewbit.com/problems/nearest-smaller-element/

Problem Name: Nearest Smaller Element
We need to find the "previous smaller element" for each element in the array.

------------------------------------------------------------------------------------
Brute Force Approach
------------------------------------------------------------------------------------
Explanation:
- For each element A[i], look to the left side (j = i-1 → 0).
- Find the nearest element smaller than A[i].
- If found, store it; else store -1.

Dry Run:
A = [2, 1, 5, 6, 2, 3]
- For 2 → no left element → -1
- For 1 → no smaller on left → -1
- For 5 → nearest smaller = 1
- For 6 → nearest smaller = 5
- For 2 → nearest smaller = 1
- For 3 → nearest smaller = 2
Result = [-1, -1, 1, 5, 1, 2]

Time Complexity: O(N^2)
Space Complexity: O(1)
*/

class SolutionBruteForce {
    public ArrayList<Integer> prevSmaller(ArrayList<Integer> A) {
        ArrayList<Integer> result = new ArrayList<>();
        int n = A.size();

        for (int i = 0; i < n; i++) {
            int prevSmaller = -1;
            for (int j = i - 1; j >= 0; j--) {
                if (A.get(j) < A.get(i)) {
                    prevSmaller = A.get(j);
                    break;
                }
            }
            result.add(prevSmaller);
        }
        return result;
    }
}

/*
------------------------------------------------------------------------------------
Optimized Approach (Monotonic Increasing Stack)
------------------------------------------------------------------------------------
Explanation:
- Use a stack that stores elements in increasing order.
- For each element:
  - Pop all elements >= current.
  - If stack empty → -1, else top is previous smaller.
  - Push current element onto stack.

Dry Run:
A = [2, 1, 5, 6, 2, 3]

| Index | Element | Stack Before | Action Taken | Stack After | Result |
|-------|---------|--------------|--------------|-------------|--------|
| 0     | 2       | []           | No smaller   | [2]         | -1     |
| 1     | 1       | [2]          | Pop(2)       | [1]         | -1     |
| 2     | 5       | [1]          | Top=1        | [1,5]       | 1      |
| 3     | 6       | [1,5]        | Top=5        | [1,5,6]     | 5      |
| 4     | 2       | [1,5,6]      | Pop(6,5)     | [1,2]       | 1      |
| 5     | 3       | [1,2]        | Top=2        | [1,2,3]     | 2      |

Output = [-1, -1, 1, 5, 1, 2]

Time Complexity: O(N)  (each element pushed & popped at most once)
Space Complexity: O(N) (stack)
*/

import java.util.ArrayList;
import java.util.Stack;

class SolutionOptimized {
    public ArrayList<Integer> prevSmaller(ArrayList<Integer> A) {
        ArrayList<Integer> result = new ArrayList<>();
        Stack<Integer> st = new Stack<>();

        for (int num : A) {
            while (!st.isEmpty() && st.peek() >= num) {
                st.pop();
            }
            if (st.isEmpty()) result.add(-1);
            else result.add(st.peek());

            st.push(num);
        }
        return result;
    }
}
