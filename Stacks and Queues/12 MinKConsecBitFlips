/*
ğŸ”— Problem: K Consecutive Bit Flips
   https://www.geeksforgeeks.org/problems/number-of-k-consecutive-bit-flips/1

ğŸ“ Problem Statement:
   Given a binary array `arr[]` and an integer k, we can flip any k consecutive bits (0->1, 1->0).
   Return the minimum number of flips required to make the array all 1s, 
   or -1 if itâ€™s impossible.
*/

/*
------------------------------------------------
âœ… Approach 1: Brute Force
------------------------------------------------
- Traverse from left to right.
- If the current bit is 0, flip the next k bits.
- Continue until end.
- At the end, check if all are 1s.
- If not possible (last k window goes out of bounds), return -1.

Dry Run Example:
   arr = [0,1,0], k=1
   i=0 â†’ arr[0]=0 â†’ flip [0] â†’ arr=[1,1,0], res=1
   i=1 â†’ arr[1]=1 â†’ no flip
   i=2 â†’ arr[2]=0 â†’ flip [2] â†’ arr=[1,1,1], res=2
   Output: 2

â±ï¸ Time Complexity: O(n*k)
ğŸ“¦ Space Complexity: O(1)
*/
class BruteForceSolution {
    static int kBitFlips(int[] arr, int k) {
        int n = arr.length;
        int res = 0;

        // Traverse array
        for (int i=0; i<=n-k; i++) {
            if(arr[i] == 0) {
                // Flip next k bits
                for(int j=i; j<i+k; j++) {
                    arr[j] ^= 1;
                }
                res++;
            }
        }

        // Check if last elements are all 1
        for(int i=n-k+1; i<n; i++) {
            if(arr[i] == 0) return -1;
        }

        return res;
    }
}


/*
------------------------------------------------
âœ… Approach 2: Optimized using Sliding Window + Queue
------------------------------------------------
- Use a queue to track flips affecting the current index.
- Maintain a `flag` that represents cumulative flips applied at current index.
- If arr[i] after flips becomes 0, we must flip this window.
- Push info into queue to keep track of "where the effect of flip ends".
- If we go out of bounds, return -1.

Dry Run Example:
   arr = [0,1,0], k=1
   i=0 â†’ arr[0]=0 â†’ flip â†’ res=1, queue=[1]
   i=1 â†’ queue removes index 0 flip â†’ arr[1]=1 â†’ no flip
   i=2 â†’ arr[2]=0 â†’ flip â†’ res=2, queue=[2]
   Output: 2

â±ï¸ Time Complexity: O(n)
ğŸ“¦ Space Complexity: O(k) for queue
*/
class OptimizedSolution {
    static int kBitFlips(int[] arr, int k) {
        int n = arr.length;
        int res = 0;
        int flag = 0; // current flip state
        Queue<Integer> q = new LinkedList<>();

        for(int i=0; i<n; i++) {
            // Remove expired flips (when window exceeded k size)
            if(i >= k) {
                flag ^= q.poll();
            }

            // Apply current flip state to arr[i]
            if(flag == 1) {
                arr[i] ^= 1;
            }

            // If arr[i] is 0, we must flip from here
            if(arr[i] == 0) {
                if(i+k > n) return -1; // not enough elements to flip

                res++;
                flag ^= 1;      // toggle flip state
                q.offer(1);     // mark flip effect
            }
            else {
                q.offer(0);     // no flip at this index
            }
        }
        return res;
    }
}
