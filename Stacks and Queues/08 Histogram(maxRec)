/*
Leetcode: https://leetcode.com/problems/largest-rectangle-in-histogram/
GFG: https://www.geeksforgeeks.org/batch/gfg-160-problems/track/stack-gfg-160/problem/maximum-rectangular-area-in-a-histogram-1587115620

Problem: Largest Rectangle in Histogram
------------------------------------------------------

Brute Force Approach:
------------------------------------------------------
Explanation:
- For every bar, expand to the left and right until we find a bar smaller than the current one.
- Calculate area = height[i] * width, update maximum.
- This checks all possible rectangles.

Dry Run:
arr = [2, 1, 5, 6, 2, 3]

- For bar at index 0 → height=2 → width=1 → area=2
- For bar at index 1 → height=1 → width=6 → area=6
- For bar at index 2 → height=5 → width=2 → area=10
- For bar at index 3 → height=6 → width=1 → area=6
- For bar at index 4 → height=2 → width=3 → area=6
- For bar at index 5 → height=3 → width=1 → area=3

Max Area = 10

Time Complexity: O(N^2)
Space Complexity: O(1)
*/

class SolutionBruteForce {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int maxArea = 0;

        for (int i = 0; i < n; i++) {
            int height = heights[i];
            int left = i, right = i;

            // expand left
            while (left > 0 && heights[left - 1] >= height) {
                left--;
            }

            // expand right
            while (right < n - 1 && heights[right + 1] >= height) {
                right++;
            }

            int width = right - left + 1;
            maxArea = Math.max(maxArea, height * width);
        }
        return maxArea;
    }
}

/*
Optimized Approach (Monotonic Stack):
------------------------------------------------------
Explanation:
1. Use a stack to store indices of increasing bar heights.
2. When a smaller bar is found, pop bars and calculate area with popped height.
3. Width = currentIndex - stackTopAfterPop - 1.
4. Continue until all bars are processed.

Dry Run:
arr = [2,1,5,6,2,3]

| Step | i  | Stack(Index) | Popped | Width  | Height | Area | Max Area |
|------|----|--------------|--------|--------|--------|------|----------|
| 1    | 0  | [0]          | -      | -      | -      | -    | 0        |
| 2    | 1  | []           | 0      | 1      | 2      | 2    | 2        |
| 3    | 1  | [1]          | -      | -      | -      | -    | 2        |
| 4    | 2  | [1,2]        | -      | -      | -      | -    | 2        |
| 5    | 3  | [1,2,3]      | -      | -      | -      | -    | 2        |
| 6    | 4  | [1]          | 3,2    | 2,3    | 6,5    | 12,10| 12       |
| 7    | 4  | [1,4]        | -      | -      | -      | -    | 12       |
| 8    | 5  | [1,4,5]      | -      | -      | -      | -    | 12       |
| 9    | 6  | []           | 5,4,1  | 1,4,6  | 3,2,1  | 3,8,6| 12       |

Max Area = 12

Time Complexity: O(N)  (each element pushed & popped once)
Space Complexity: O(N) (stack)
*/

import java.util.Stack;

class SolutionOptimized {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> st = new Stack<>();
        int maxA = 0;
        int n = heights.length;

        for (int i = 0; i <= n; i++) {
            while (!st.isEmpty() && (i == n || heights[st.peek()] >= heights[i])) {
                int height = heights[st.pop()];
                int width;
                if (st.isEmpty()) width = i;
                else width = i - st.peek() - 1;

                maxA = Math.max(maxA, height * width);
            }
            st.push(i);
        }
        return maxA;
    }
}
