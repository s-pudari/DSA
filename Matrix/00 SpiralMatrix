// https://leetcode.com/problems/spiral-matrix/
/*
üî• PROBLEM: Spiral Matrix (LeetCode 54)
---------------------------------------
Given an m x n matrix, return all elements of the matrix in spiral order.

üß† Explanation in my own words:
We have to traverse the matrix in a spiral fashion ‚Üí first row left‚Üíright,
then last column top‚Üíbottom, then last row right‚Üíleft, then first column bottom‚Üítop,
then move inward and repeat until all elements are covered.

=======================================================================
STRUCTURE (as per your requirement):
1Ô∏è‚É£ Brute-force approach (explanation, dry run, code)
2Ô∏è‚É£ Optimized approach (explanation, dry run, code)
=======================================================================
*/

import java.util.*;

class Solution {

    /* ============================================================
       1Ô∏è‚É£ BRUTE-FORCE APPROACH
       ------------------------------------------------------------
       üí° Idea:
       - Maintain a visited matrix (boolean) of same size as input.
       - Move in four directions (right, down, left, up) cyclically.
       - At each step, mark cell visited and append to result.
       - When next move is invalid or already visited, turn clockwise.
       
       üïí Time Complexity: O(n*m)
       üß† Space Complexity: O(n*m) (for visited matrix)
       
       Dry run (matrix = [[1,2,3],[4,5,6],[7,8,9]]):
       Start (0,0) ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí turn down ‚Üí 6 ‚Üí 9 ‚Üí turn left ‚Üí 8 ‚Üí 7 ‚Üí
       turn up ‚Üí 4 ‚Üí turn right ‚Üí 5
       Output = [1,2,3,6,9,8,7,4,5]
    */
    public List<Integer> spiralOrderBrute(int[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        boolean[][] visited = new boolean[n][m];
        List<Integer> ans = new ArrayList<>();
        
        /* Directions: right, down, left, up */
        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
        int dir = 0; // start moving right
        int i = 0, j = 0;
        
        for (int k = 0; k < n*m; k++) {
            ans.add(matrix[i][j]);
            visited[i][j] = true;
            
            int ni = i + dirs[dir][0];
            int nj = j + dirs[dir][1];
            
            /* If next cell is out of bounds or visited, turn clockwise */
            if (ni < 0 || nj < 0 || ni >= n || nj >= m || visited[ni][nj]) {
                dir = (dir + 1) % 4; // change direction
                ni = i + dirs[dir][0];
                nj = j + dirs[dir][1];
            }
            i = ni;
            j = nj;
        }
        return ans;
    }

    /* ============================================================
       2Ô∏è‚É£ OPTIMIZED BOUNDARY APPROACH
       ------------------------------------------------------------
       üí° Idea:
       - Use 4 pointers: top, bottom, left, right.
       - Traverse in layers: 
         ‚Üí left‚Üíright across top row, increment top
         ‚Üí top‚Üíbottom along right col, decrement right
         ‚Üí right‚Üíleft across bottom row (if top<=bottom), decrement bottom
         ‚Üí bottom‚Üítop along left col (if left<=right), increment left
       - Repeat until boundaries cross.

       üïí Time Complexity: O(n*m)
       üß† Space Complexity: O(1) extra (besides result list)
       
       Dry run (matrix = [[1,2,3],[4,5,6],[7,8,9]]):
       top=0,bottom=2,left=0,right=2
       ‚Üí [1,2,3]
       ‚Üí [6,9]
       ‚Üí [8,7]
       ‚Üí [4]
       ‚Üí [5]
       Output = [1,2,3,6,9,8,7,4,5]
    */
    public List<Integer> spiralOrder(int[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        List<Integer> ans = new ArrayList<>();
        
        int top = 0, bottom = n-1, left = 0, right = m-1;
        
        while (top <= bottom && left <= right) {
            
            /* Traverse top row left‚Üíright */
            for (int i = left; i <= right; i++) {
                ans.add(matrix[top][i]);
            }
            top++;
            
            /* Traverse right column top‚Üíbottom */
            for (int i = top; i <= bottom; i++) {
                ans.add(matrix[i][right]);
            }
            right--;
            
            /* Traverse bottom row right‚Üíleft if still valid */
            if (top <= bottom) {
                for (int i = right; i >= left; i--) {
                    ans.add(matrix[bottom][i]);
                }
                bottom--;
            }
            
            /* Traverse left column bottom‚Üítop if still valid */
            if (left <= right) {
                for (int i = bottom; i >= top; i--) {
                    ans.add(matrix[i][left]);
                }
                left++;
            }
        }
        
        return ans;
    }
}
